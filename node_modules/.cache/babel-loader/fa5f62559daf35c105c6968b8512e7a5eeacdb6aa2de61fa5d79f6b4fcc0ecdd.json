{"ast":null,"code":"/**\n * Database utilities for direct data access\n */\n\nimport { supabase, getServiceClient } from '../lib/supabaseClient';\n\n// Valores de autenticación de Supabase\nconst SUPABASE_URL = 'https://ydnygntfkrleiseuciwq.supabase.co';\nconst SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnlnbnRma3JsZWlzZXVjaXdxIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczOTk5MjQwNiwiZXhwIjoyMDU1NTY4NDA2fQ.TwhEGW9DK4DTQQRquT6Z9UW8T8UjLX-hp9uKdRjWAhs';\n\n// Use the imported supabase client instead of creating a new one\n// This helps ensure we only have one client instance across the app\n\n// Add a cache for approval status to persist data during connection issues\nconst approvalStatusCache = new Map();\n\n// Track connection status\nlet supabaseConnected = true;\nlet lastConnectionAttempt = 0;\nconst CONNECTION_RETRY_INTERVAL = 30000; // 30 seconds\n\n// Helper function to parse SQL query\nexport const parseQuery = query => {\n  const queryLower = query.toLowerCase();\n\n  // Detect query type\n  let type = 'select';\n  if (queryLower.startsWith('insert')) type = 'insert';\n  if (queryLower.startsWith('update')) type = 'update';\n  if (queryLower.startsWith('delete')) type = 'delete';\n\n  // Extract table name\n  let table = '';\n  if (type === 'select') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  } else if (type === 'insert') {\n    const intoMatch = queryLower.match(/into\\s+([a-z0-9_]+)/i);\n    if (intoMatch && intoMatch[1]) table = intoMatch[1];\n  } else if (type === 'update') {\n    const updateMatch = queryLower.match(/update\\s+([a-z0-9_]+)/i);\n    if (updateMatch && updateMatch[1]) table = updateMatch[1];\n  } else if (type === 'delete') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  }\n\n  // Extract conditions from WHERE clause (simplified)\n  let conditions = {};\n  const whereMatch = queryLower.match(/where\\s+(.*?)(?:order by|group by|limit|$)/i);\n  if (whereMatch && whereMatch[1]) {\n    const whereClause = whereMatch[1].trim();\n\n    // For simpler queries, try to parse conditions\n    // This is a very basic implementation and might not work for complex conditions\n    const condPairs = whereClause.split(/\\s+and\\s+/i);\n    condPairs.forEach(pair => {\n      const equalMatch = pair.match(/([a-z0-9_]+)\\s*=\\s*'([^']+)'/i);\n      if (equalMatch) {\n        conditions[equalMatch[1]] = equalMatch[2];\n      }\n    });\n  }\n  return {\n    table,\n    type,\n    conditions\n  };\n};\n\n// Execute query specifically with Supabase\nexport const executeSupabaseQuery = async (table, type, conditions, originalQuery) => {\n  if (!table) {\n    throw new Error('Table name is required for Supabase query execution');\n  }\n  try {\n    let result;\n    if (type === 'select') {\n      // For select queries, use Supabase query builder\n      let query = supabase.from(table).select('*');\n\n      // Apply conditions if available\n      if (conditions && Object.keys(conditions).length > 0) {\n        Object.entries(conditions).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n      const {\n        data,\n        error\n      } = await query;\n      if (error) throw error;\n      result = data || [];\n    } else {\n      // For other query types, we'd need more complex logic\n      // This is a simplified implementation\n      console.warn('Non-SELECT queries are not fully implemented in executeSupabaseQuery');\n      throw new Error('Only SELECT queries are supported in this implementation');\n    }\n    return result;\n  } catch (error) {\n    console.error('Supabase query execution error:', error);\n    throw error;\n  }\n};\n\n// Execute query with MCP server\nexport const executeMcpQuery = async query => {\n  try {\n    // Here we would implement the logic to send the query to the MCP server\n    // For now, this is a placeholder that simulates an MCP call\n    const response = await fetch('/api/mcp-query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`MCP server responded with status: ${response.status}`);\n    }\n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    console.error('MCP server connection error:', error);\n    throw error;\n  }\n};\n\n// Helper function to check and potentially reconnect to Supabase\nexport const ensureSupabaseConnection = async () => {\n  const now = Date.now();\n\n  // Only retry connection every 30 seconds to avoid too many reconnect attempts\n  if (!supabaseConnected && now - lastConnectionAttempt > CONNECTION_RETRY_INTERVAL) {\n    console.log('Attempting to reconnect to Supabase...');\n    lastConnectionAttempt = now;\n    try {\n      // Simple health check query\n      const {\n        data,\n        error\n      } = await supabase.from('applications').select('count(*)', {\n        count: 'exact'\n      }).limit(1);\n      if (error) {\n        console.error('Supabase reconnection failed:', error);\n        supabaseConnected = false;\n        return false;\n      }\n      console.log('Successfully reconnected to Supabase');\n      supabaseConnected = true;\n      return true;\n    } catch (error) {\n      console.error('Supabase reconnection error:', error);\n      supabaseConnected = false;\n      return false;\n    }\n  }\n  return supabaseConnected;\n};\n\n// Function to execute a database query\nexport const executeQuery = async sqlQuery => {\n  try {\n    // Use service client for direct SQL access\n    const serviceClient = getServiceClient();\n    const {\n      data,\n      error\n    } = await serviceClient.rpc('execute_sql', {\n      query: sqlQuery\n    });\n    if (error) {\n      console.error('SQL query execution error:', error);\n      throw error;\n    }\n    return data || [];\n  } catch (error) {\n    console.error('Error executing query:', error);\n    throw error;\n  }\n};\n\n// Function to reinitialize Supabase client in case of connection issues\nexport const reinitializeSupabaseClient = () => {\n  console.log('Reinitializing Supabase client connection...');\n  // Since we're now using the imported client, we can't recreate it here,\n  // but we can test the connection to effectively reinitialize the session\n  return testSupabaseConnection().then(connected => {\n    supabaseConnected = connected;\n    return supabase;\n  });\n};\n\n// Function to test the Supabase connection\nexport const testSupabaseConnection = async () => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('applications').select('count(*)', {\n      count: 'exact'\n    }).limit(1);\n    if (error) {\n      console.error('Supabase connection test failed:', error);\n      return false;\n    }\n    console.log('Supabase connection test successful');\n    return true;\n  } catch (error) {\n    console.error('Supabase connection test error:', error);\n    return false;\n  }\n};\n\n// Export supabase client for direct usage\nexport { supabase };\n\n/**\n * Escapes a string for SQL queries to prevent SQL injection\n * @param str - String to escape\n * @returns Escaped string\n */\nexport const escapeSqlString = str => {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n};\n\n/**\n * Formats a date for SQL queries\n * @param date - Date to format\n * @returns Formatted date string\n */\nexport const formatDateForSQL = date => {\n  return date.toISOString().split('T')[0];\n};\n\n/**\n * Parses a PostgreSQL JSON result to a JavaScript object\n * @param jsonString - JSON string from PostgreSQL\n * @returns Parsed JavaScript object\n */\nexport const parseJsonResult = jsonString => {\n  if (!jsonString) return null;\n  try {\n    return JSON.parse(jsonString);\n  } catch (error) {\n    console.error('Error parsing JSON result:', error);\n    return null;\n  }\n};\n\n/**\n * Fetches approval statuses for multiple applications in a single batch query\n * @param ids Array of application IDs to fetch approval statuses for\n * @returns A Map with application IDs as keys and approval data as values\n */\nexport const fetchApprovalsBatch = async ids => {\n  if (!ids || ids.length === 0) {\n    return new Map();\n  }\n  try {\n    console.log(`Fetching approval statuses in batch for ${ids.length} applications`);\n\n    // Execute a single query for all IDs instead of individual queries\n    const {\n      data,\n      error\n    } = await supabase.from('applications').select('id, approved_by_advisor, approved_by_company, approval_date_advisor, approval_date_company').in('id', ids);\n    if (error) {\n      console.error('Error fetching approval statuses in batch:', error);\n      throw error;\n    }\n    if (!data || data.length === 0) {\n      console.warn('No approval data returned for batch query');\n      return new Map();\n    }\n    console.log(`Successfully fetched ${data.length} approval statuses in batch`);\n\n    // Store results in the cache\n    data.forEach(item => {\n      const cachedResultKey = `approval_status_${item.id}`;\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(item));\n      } catch (e) {\n        // Ignore storage errors\n      }\n    });\n\n    // Return a Map for easy lookup by ID\n    return new Map(data.map(item => [item.id, {\n      approvedByAdvisor: item.approved_by_advisor || false,\n      approvedByCompany: item.approved_by_company || false,\n      approvalDateAdvisor: item.approval_date_advisor,\n      approvalDateCompany: item.approval_date_company\n    }]));\n  } catch (error) {\n    console.error('Error in fetchApprovalsBatch:', error);\n    // Return empty Map on error\n    return new Map();\n  }\n};\n\n// Initialize connection status check\nsetTimeout(() => {\n  ensureSupabaseConnection();\n}, 1000);","map":{"version":3,"names":["supabase","getServiceClient","SUPABASE_URL","SERVICE_ROLE_KEY","approvalStatusCache","Map","supabaseConnected","lastConnectionAttempt","CONNECTION_RETRY_INTERVAL","parseQuery","query","queryLower","toLowerCase","type","startsWith","table","fromMatch","match","intoMatch","updateMatch","conditions","whereMatch","whereClause","trim","condPairs","split","forEach","pair","equalMatch","executeSupabaseQuery","originalQuery","Error","result","from","select","Object","keys","length","entries","key","value","eq","data","error","console","warn","executeMcpQuery","response","fetch","method","headers","body","JSON","stringify","ok","status","json","ensureSupabaseConnection","now","Date","log","count","limit","executeQuery","sqlQuery","serviceClient","rpc","reinitializeSupabaseClient","testSupabaseConnection","then","connected","escapeSqlString","str","replace","formatDateForSQL","date","toISOString","parseJsonResult","jsonString","parse","fetchApprovalsBatch","ids","in","item","cachedResultKey","id","sessionStorage","setItem","e","map","approvedByAdvisor","approved_by_advisor","approvedByCompany","approved_by_company","approvalDateAdvisor","approval_date_advisor","approvalDateCompany","approval_date_company","setTimeout"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/databaseUtils.ts"],"sourcesContent":["/**\n * Database utilities for direct data access\n */\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { TABLES } from './constants/tables';\nimport { supabase, getServiceClient } from '../lib/supabaseClient';\n\n// Valores de autenticación de Supabase\nconst SUPABASE_URL = 'https://ydnygntfkrleiseuciwq.supabase.co';\nconst SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnlnbnRma3JsZWlzZXVjaXdxIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczOTk5MjQwNiwiZXhwIjoyMDU1NTY4NDA2fQ.TwhEGW9DK4DTQQRquT6Z9UW8T8UjLX-hp9uKdRjWAhs';\n\n// Use the imported supabase client instead of creating a new one\n// This helps ensure we only have one client instance across the app\n\n// Add a cache for approval status to persist data during connection issues\nconst approvalStatusCache = new Map<string, any>();\n\n// Track connection status\nlet supabaseConnected = true;\nlet lastConnectionAttempt = 0;\nconst CONNECTION_RETRY_INTERVAL = 30000; // 30 seconds\n\n// Helper function to parse SQL query\nexport const parseQuery = (query: string): { table: string; type: string; conditions: any } => {\n  const queryLower = query.toLowerCase();\n  \n  // Detect query type\n  let type = 'select';\n  if (queryLower.startsWith('insert')) type = 'insert';\n  if (queryLower.startsWith('update')) type = 'update';\n  if (queryLower.startsWith('delete')) type = 'delete';\n  \n  // Extract table name\n  let table = '';\n  if (type === 'select') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  } else if (type === 'insert') {\n    const intoMatch = queryLower.match(/into\\s+([a-z0-9_]+)/i);\n    if (intoMatch && intoMatch[1]) table = intoMatch[1];\n  } else if (type === 'update') {\n    const updateMatch = queryLower.match(/update\\s+([a-z0-9_]+)/i);\n    if (updateMatch && updateMatch[1]) table = updateMatch[1];\n  } else if (type === 'delete') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  }\n  \n  // Extract conditions from WHERE clause (simplified)\n  let conditions: any = {};\n  const whereMatch = queryLower.match(/where\\s+(.*?)(?:order by|group by|limit|$)/i);\n  if (whereMatch && whereMatch[1]) {\n    const whereClause = whereMatch[1].trim();\n    \n    // For simpler queries, try to parse conditions\n    // This is a very basic implementation and might not work for complex conditions\n    const condPairs = whereClause.split(/\\s+and\\s+/i);\n    condPairs.forEach(pair => {\n      const equalMatch = pair.match(/([a-z0-9_]+)\\s*=\\s*'([^']+)'/i);\n      if (equalMatch) {\n        conditions[equalMatch[1]] = equalMatch[2];\n      }\n    });\n  }\n  \n  return { table, type, conditions };\n};\n\n// Execute query specifically with Supabase\nexport const executeSupabaseQuery = async (\n  table: string, \n  type: string, \n  conditions: any, \n  originalQuery: string\n): Promise<any[]> => {\n  if (!table) {\n    throw new Error('Table name is required for Supabase query execution');\n  }\n  \n  try {\n    let result;\n    \n    if (type === 'select') {\n      // For select queries, use Supabase query builder\n      let query = supabase.from(table).select('*');\n      \n      // Apply conditions if available\n      if (conditions && Object.keys(conditions).length > 0) {\n        Object.entries(conditions).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) throw error;\n      result = data || [];\n    } else {\n      // For other query types, we'd need more complex logic\n      // This is a simplified implementation\n      console.warn('Non-SELECT queries are not fully implemented in executeSupabaseQuery');\n      throw new Error('Only SELECT queries are supported in this implementation');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Supabase query execution error:', error);\n    throw error;\n  }\n};\n\n// Execute query with MCP server\nexport const executeMcpQuery = async (query: string): Promise<any[]> => {\n  try {\n    // Here we would implement the logic to send the query to the MCP server\n    // For now, this is a placeholder that simulates an MCP call\n    const response = await fetch('/api/mcp-query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`MCP server responded with status: ${response.status}`);\n    }\n    \n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    console.error('MCP server connection error:', error);\n    throw error;\n  }\n};\n\n// Helper function to check and potentially reconnect to Supabase\nexport const ensureSupabaseConnection = async (): Promise<boolean> => {\n  const now = Date.now();\n  \n  // Only retry connection every 30 seconds to avoid too many reconnect attempts\n  if (!supabaseConnected && (now - lastConnectionAttempt) > CONNECTION_RETRY_INTERVAL) {\n    console.log('Attempting to reconnect to Supabase...');\n    lastConnectionAttempt = now;\n    \n    try {\n      // Simple health check query\n      const { data, error } = await supabase.from('applications').select('count(*)', { count: 'exact' }).limit(1);\n      \n      if (error) {\n        console.error('Supabase reconnection failed:', error);\n        supabaseConnected = false;\n        return false;\n      }\n      \n      console.log('Successfully reconnected to Supabase');\n      supabaseConnected = true;\n      return true;\n    } catch (error) {\n      console.error('Supabase reconnection error:', error);\n      supabaseConnected = false;\n      return false;\n    }\n  }\n  \n  return supabaseConnected;\n};\n\n// Function to execute a database query\nexport const executeQuery = async (sqlQuery: string): Promise<any[]> => {\n  try {\n    // Use service client for direct SQL access\n    const serviceClient = getServiceClient();\n    const { data, error } = await serviceClient.rpc('execute_sql', { query: sqlQuery });\n    \n    if (error) {\n      console.error('SQL query execution error:', error);\n      throw error;\n    }\n    \n    return data || [];\n  } catch (error) {\n    console.error('Error executing query:', error);\n    throw error;\n  }\n};\n\n// Function to reinitialize Supabase client in case of connection issues\nexport const reinitializeSupabaseClient = () => {\n  console.log('Reinitializing Supabase client connection...');\n  // Since we're now using the imported client, we can't recreate it here,\n  // but we can test the connection to effectively reinitialize the session\n  return testSupabaseConnection().then(connected => {\n    supabaseConnected = connected;\n    return supabase;\n  });\n};\n\n// Function to test the Supabase connection\nexport const testSupabaseConnection = async (): Promise<boolean> => {\n  try {\n    const { data, error } = await supabase.from('applications').select('count(*)', { count: 'exact' }).limit(1);\n    if (error) {\n      console.error('Supabase connection test failed:', error);\n      return false;\n    }\n    console.log('Supabase connection test successful');\n    return true;\n  } catch (error) {\n    console.error('Supabase connection test error:', error);\n    return false;\n  }\n};\n\n// Export supabase client for direct usage\nexport { supabase };\n\n/**\n * Escapes a string for SQL queries to prevent SQL injection\n * @param str - String to escape\n * @returns Escaped string\n */\nexport const escapeSqlString = (str: string): string => {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n};\n\n/**\n * Formats a date for SQL queries\n * @param date - Date to format\n * @returns Formatted date string\n */\nexport const formatDateForSQL = (date: Date): string => {\n  return date.toISOString().split('T')[0];\n};\n\n/**\n * Parses a PostgreSQL JSON result to a JavaScript object\n * @param jsonString - JSON string from PostgreSQL\n * @returns Parsed JavaScript object\n */\nexport const parseJsonResult = (jsonString: string): any => {\n  if (!jsonString) return null;\n  try {\n    return JSON.parse(jsonString);\n  } catch (error) {\n    console.error('Error parsing JSON result:', error);\n    return null;\n  }\n};\n\n/**\n * Fetches approval statuses for multiple applications in a single batch query\n * @param ids Array of application IDs to fetch approval statuses for\n * @returns A Map with application IDs as keys and approval data as values\n */\nexport const fetchApprovalsBatch = async (ids: string[]) => {\n  if (!ids || ids.length === 0) {\n    return new Map();\n  }\n\n  try {\n    console.log(`Fetching approval statuses in batch for ${ids.length} applications`);\n    \n    // Execute a single query for all IDs instead of individual queries\n    const { data, error } = await supabase\n      .from('applications')\n      .select('id, approved_by_advisor, approved_by_company, approval_date_advisor, approval_date_company')\n      .in('id', ids);\n    \n    if (error) {\n      console.error('Error fetching approval statuses in batch:', error);\n      throw error;\n    }\n    \n    if (!data || data.length === 0) {\n      console.warn('No approval data returned for batch query');\n      return new Map();\n    }\n    \n    console.log(`Successfully fetched ${data.length} approval statuses in batch`);\n    \n    // Store results in the cache\n    data.forEach(item => {\n      const cachedResultKey = `approval_status_${item.id}`;\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(item));\n      } catch (e) {\n        // Ignore storage errors\n      }\n    });\n    \n    // Return a Map for easy lookup by ID\n    return new Map(data.map(item => [\n      item.id, \n      {\n        approvedByAdvisor: item.approved_by_advisor || false,\n        approvedByCompany: item.approved_by_company || false,\n        approvalDateAdvisor: item.approval_date_advisor,\n        approvalDateCompany: item.approval_date_company\n      }\n    ]));\n  } catch (error) {\n    console.error('Error in fetchApprovalsBatch:', error);\n    // Return empty Map on error\n    return new Map();\n  }\n}\n\n// Initialize connection status check\nsetTimeout(() => {\n  ensureSupabaseConnection();\n}, 1000); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}