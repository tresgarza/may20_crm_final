{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = file => {\n  // Allowed MIME types\n  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/heic', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (document, folder, attempt = 1) => {\n  const file = document.file;\n  if (!isValidDocument(file)) {\n    throw createAppError(ErrorType.VALIDATION, 'Invalid document format or size', {\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size\n    });\n  }\n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n\n    // Upload the file\n    const {\n      error: uploadError\n    } = await supabase.storage.from('client-documents').upload(filePath, file);\n    if (uploadError) {\n      throw createAppError(ErrorType.UPLOAD, `Error uploading document: ${uploadError.message}`, {\n        filePath,\n        attempt\n      }, uploadError);\n    }\n\n    // Get public URL for the uploaded file\n    const {\n      data: publicUrlData\n    } = supabase.storage.from('client-documents').getPublicUrl(filePath);\n\n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', {\n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n\n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n\n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (documents, folder) => {\n  const uploadedDocs = [];\n  const failedDocs = [];\n\n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(uploadDocumentToStorage(document, folder), 'uploadDocuments');\n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({\n        document,\n        error\n      });\n    }\n  }\n  return {\n    uploadedDocs,\n    failedDocs\n  };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName = 'client-documents') => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n\n    // Intentar listar buckets para verificar si existe\n    const {\n      data: buckets,\n      error: listError\n    } = await storage.listBuckets();\n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      // Si hay un error al listar buckets, podría ser un problema de permisos\n      // Intentaremos verificar directamente intentando listar archivos del bucket\n      const {\n        error: listFilesError\n      } = await storage.from(bucketName).list();\n      if (!listFilesError) {\n        // Si no hay error al listar archivos, significa que el bucket existe\n        console.log(`El bucket ${bucketName} existe y es accesible.`);\n        return true;\n      }\n      throw createAppError(ErrorType.UPLOAD, `Error al acceder al almacenamiento: ${listError.message}`, {\n        error: listError\n      });\n    }\n\n    // Verificar si el bucket ya existe\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === bucketName);\n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n\n    // Crear el bucket si no existe\n    const MAX_RETRIES = 2;\n    let attempt = 0;\n    let lastError = null;\n    while (attempt < MAX_RETRIES) {\n      try {\n        const {\n          data,\n          error: createError\n        } = await storage.createBucket(bucketName, {\n          public: false\n        });\n        if (createError) {\n          var _createError$message;\n          console.error(`Error al crear el bucket ${bucketName} (intento ${attempt + 1}/${MAX_RETRIES}):`, createError);\n          lastError = createError;\n\n          // Si el error indica que el bucket ya existe, consideremos eso un éxito\n          if ((_createError$message = createError.message) !== null && _createError$message !== void 0 && _createError$message.includes('already exists')) {\n            console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);\n            return true;\n          }\n          throw createError;\n        }\n        console.log(`Bucket ${bucketName} creado correctamente.`);\n\n        // Intentar establecer políticas públicas para el bucket\n        try {\n          // Verificar que podemos acceder al bucket recién creado\n          const {\n            error: testError\n          } = await storage.from(bucketName).list('', {\n            limit: 1\n          });\n          if (testError) {\n            console.warn(`Advertencia: El bucket ${bucketName} fue creado pero hay problemas para acceder a él: ${testError.message}`);\n          } else {\n            console.log(`Bucket ${bucketName} creado y accesible correctamente.`);\n          }\n        } catch (policyError) {\n          // No bloquear el proceso si falla la verificación\n          console.warn(`No se pudo verificar acceso al bucket ${bucketName}:`, policyError);\n        }\n        return true;\n      } catch (error) {\n        lastError = error;\n        attempt++;\n\n        // Si no es el último intento, esperar antes de reintentar\n        if (attempt < MAX_RETRIES) {\n          const waitTime = 1000 * Math.pow(2, attempt - 1); // Backoff exponencial\n          console.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    throw lastError || new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);\n  } catch (error) {\n    // Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\n    try {\n      const storage = getStorage();\n      const testFilePath = `test-${Date.now()}.txt`;\n      const testContent = new Blob(['test'], {\n        type: 'text/plain'\n      });\n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);\n      const {\n        error: uploadError\n      } = await storage.from(bucketName).upload(testFilePath, testContent);\n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n    } catch (testError) {\n      console.error(`Error en la prueba final de escritura en bucket:`, testError);\n    }\n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw createAppError(ErrorType.UPLOAD, error instanceof Error ? `Error al crear el bucket de almacenamiento: ${error.message}` : 'Error desconocido al crear el bucket de almacenamiento', {\n      bucketName,\n      error\n    });\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (clientId, documents, maxRetries = 2) => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    let bucketName = 'client-documents';\n    console.log(`Iniciando proceso de subida de documentos para cliente ${clientId}`);\n    console.log(`Total de documentos: ${documents.length}`);\n    let bucketReady = false;\n    try {\n      bucketReady = await ensureClientBucketExists(bucketName);\n      if (bucketReady) {\n        console.log(`Bucket ${bucketName} verificado y listo para su uso.`);\n      }\n    } catch (bucketError) {\n      console.error(`Error preparando el bucket ${bucketName}:`, bucketError);\n      // Intentar continuar usando el bucket predeterminado 'documents' como fallback\n      bucketName = 'documents';\n      console.log(`Intentando usar el bucket predeterminado '${bucketName}' como alternativa...`);\n      try {\n        bucketReady = await ensureClientBucketExists(bucketName);\n        if (bucketReady) {\n          console.log(`Usando bucket alternativo '${bucketName}' para la subida.`);\n        }\n      } catch (fallbackError) {\n        console.error(`No se pudo usar ningún bucket para la subida:`, fallbackError);\n        throw createAppError(ErrorType.UPLOAD, `No se pudo preparar un bucket para subir documentos. Contacte al administrador.`, {\n          originalError: bucketError\n        });\n      }\n    }\n    const storage = getStorage();\n    const uploadedDocs = [];\n    const failedDocs = [];\n\n    // Filter out docs with invalid or missing files\n    const validDocs = documents.filter(doc => doc && doc.file && doc.file instanceof File && doc.category && doc.name);\n    console.log(`Documentos válidos para subida: ${validDocs.length} de ${documents.length}`);\n    if (validDocs.length === 0) {\n      console.warn(`No hay documentos válidos para subir. Se requiere archivo, categoría y nombre.`);\n      return [];\n    }\n    for (let docIndex = 0; docIndex < validDocs.length; docIndex++) {\n      const doc = validDocs[docIndex];\n      let fileUrl = '';\n      let success = false;\n      let retries = 0;\n      let lastError = null;\n      console.log(`Procesando documento ${docIndex + 1}/${validDocs.length}: \"${doc.name}\" (${doc.file.size} bytes)`);\n      while (!success && retries <= maxRetries) {\n        retries++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileNameSafe = doc.file.name.replace(/[^a-zA-Z0-9.-]/g, '_'); // Sanitizar nombre de archivo\n          const fileName = `${timestamp}_${fileNameSafe}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n          console.log(`Intento ${retries}/${maxRetries + 1}: Subiendo \"${doc.name}\" a ${bucketName}/${filePath}`);\n\n          // Upload the file\n          const {\n            data,\n            error\n          } = await storage.from(bucketName).upload(filePath, doc.file, {\n            cacheControl: '3600',\n            upsert: true // Cambiar a true para sobrescribir si existe\n          });\n          if (error) {\n            console.error(`Error al subir archivo \"${doc.name}\" (intento ${retries}/${maxRetries + 1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const {\n            data: urlData\n          } = storage.from(bucketName).getPublicUrl(filePath);\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`✅ Documento \"${doc.name}\" subido exitosamente a ${bucketName}/${filePath}`);\n        } catch (error) {\n          lastError = error;\n\n          // Imprimir detalles adicionales del error para diagnóstico\n          if (error instanceof Error) {\n            console.error(`Detalles del error: ${error.message}`);\n            if (error.stack) {\n              console.error(`Stack: ${error.stack}`);\n            }\n          }\n\n          // Si no es el último intento, esperar antes de reintentar\n          if (retries <= maxRetries) {\n            const waitTime = Math.pow(2, retries - 1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar la subida...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`❌ Falló la subida de \"${doc.name}\" después de ${retries} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n\n            // Create a proper AppError and log it\n            const uploadError = createAppError(ErrorType.UPLOAD, `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries + 1} intentos`, {\n              documentName: doc.name,\n              clientId,\n              category: doc.category,\n              attempts: retries\n            }, error);\n            logError(uploadError, 'uploadClientDocuments');\n          }\n        }\n      }\n      if (success) {\n        // Create document without the file property\n        const {\n          file,\n          ...docWithoutFile\n        } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n    if (failedDocs.length > 0) {\n      console.warn(`⚠️ ${failedDocs.length} documentos fallaron al subirse de un total de ${validDocs.length}:`, failedDocs);\n    }\n    console.log(`📊 Resumen: ${uploadedDocs.length} documentos subidos exitosamente, ${failedDocs.length} fallidos.`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('❌ Error general en uploadClientDocuments:', error);\n\n    // Proporcionar un mensaje de error más descriptivo basado en el tipo de error\n    let errorMessage = 'Error al subir documentos';\n    if (error instanceof Error) {\n      errorMessage = error.message;\n    } else if (typeof error === 'object' && error !== null && 'message' in error) {\n      errorMessage = error.message || errorMessage;\n    }\n    throw createAppError(ErrorType.UPLOAD, errorMessage, {\n      clientId,\n      error\n    });\n  }\n};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","getStorage","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","ensureClientBucketExists","bucketName","console","log","buckets","listError","listBuckets","listFilesError","list","bucketExists","some","bucket","MAX_RETRIES","lastError","createError","createBucket","public","_createError$message","testError","limit","warn","policyError","waitTime","Error","testFilePath","now","testContent","Blob","remove","uploadClientDocuments","clientId","maxRetries","Array","isArray","length","bucketReady","bucketError","fallbackError","originalError","validDocs","filter","doc","File","category","docIndex","fileUrl","success","retries","timestamp","getTime","fileNameSafe","replace","cacheControl","upsert","urlData","stack","documentName","attempts","docWithoutFile","errorMessage"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\nimport { ClientDocument } from '../types/client';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from('client-documents')\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from('client-documents')\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName: string = 'client-documents'): Promise<boolean> => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n    \n    // Intentar listar buckets para verificar si existe\n    const { data: buckets, error: listError } = await storage.listBuckets();\n    \n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      // Si hay un error al listar buckets, podría ser un problema de permisos\n      // Intentaremos verificar directamente intentando listar archivos del bucket\n      const { error: listFilesError } = await storage.from(bucketName).list();\n      \n      if (!listFilesError) {\n        // Si no hay error al listar archivos, significa que el bucket existe\n        console.log(`El bucket ${bucketName} existe y es accesible.`);\n        return true;\n      }\n      \n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error al acceder al almacenamiento: ${listError.message}`,\n        { error: listError }\n      );\n    }\n    \n    // Verificar si el bucket ya existe\n    const bucketExists = buckets?.some(bucket => bucket.name === bucketName);\n    \n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    \n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n    \n    // Crear el bucket si no existe\n    const MAX_RETRIES = 2;\n    let attempt = 0;\n    let lastError = null;\n    \n    while (attempt < MAX_RETRIES) {\n      try {\n        const { data, error: createError } = await storage.createBucket(bucketName, {\n          public: false\n        });\n        \n        if (createError) {\n          console.error(`Error al crear el bucket ${bucketName} (intento ${attempt + 1}/${MAX_RETRIES}):`, createError);\n          lastError = createError;\n          \n          // Si el error indica que el bucket ya existe, consideremos eso un éxito\n          if (createError.message?.includes('already exists')) {\n            console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);\n            return true;\n          }\n          \n          throw createError;\n        }\n        \n        console.log(`Bucket ${bucketName} creado correctamente.`);\n        \n        // Intentar establecer políticas públicas para el bucket\n        try {\n          // Verificar que podemos acceder al bucket recién creado\n          const { error: testError } = await storage.from(bucketName).list('', {\n            limit: 1\n          });\n          \n          if (testError) {\n            console.warn(`Advertencia: El bucket ${bucketName} fue creado pero hay problemas para acceder a él: ${testError.message}`);\n          } else {\n            console.log(`Bucket ${bucketName} creado y accesible correctamente.`);\n          }\n        } catch (policyError) {\n          // No bloquear el proceso si falla la verificación\n          console.warn(`No se pudo verificar acceso al bucket ${bucketName}:`, policyError);\n        }\n        \n        return true;\n      } catch (error) {\n        lastError = error;\n        attempt++;\n        \n        // Si no es el último intento, esperar antes de reintentar\n        if (attempt < MAX_RETRIES) {\n          const waitTime = 1000 * Math.pow(2, attempt - 1); // Backoff exponencial\n          console.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    throw lastError || new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);\n  } catch (error) {\n    // Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\n    try {\n      const storage = getStorage();\n      const testFilePath = `test-${Date.now()}.txt`;\n      const testContent = new Blob(['test'], { type: 'text/plain' });\n      \n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);\n      const { error: uploadError } = await storage.from(bucketName).upload(testFilePath, testContent);\n      \n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n    } catch (testError) {\n      console.error(`Error en la prueba final de escritura en bucket:`, testError);\n    }\n    \n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      error instanceof Error \n        ? `Error al crear el bucket de almacenamiento: ${error.message}` \n        : 'Error desconocido al crear el bucket de almacenamiento',\n      { bucketName, error }\n    );\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    let bucketName = 'client-documents';\n    \n    console.log(`Iniciando proceso de subida de documentos para cliente ${clientId}`);\n    console.log(`Total de documentos: ${documents.length}`);\n    \n    let bucketReady = false;\n    try {\n      bucketReady = await ensureClientBucketExists(bucketName);\n      if (bucketReady) {\n        console.log(`Bucket ${bucketName} verificado y listo para su uso.`);\n      }\n    } catch (bucketError) {\n      console.error(`Error preparando el bucket ${bucketName}:`, bucketError);\n      // Intentar continuar usando el bucket predeterminado 'documents' como fallback\n      bucketName = 'documents';\n      console.log(`Intentando usar el bucket predeterminado '${bucketName}' como alternativa...`);\n      try {\n        bucketReady = await ensureClientBucketExists(bucketName);\n        if (bucketReady) {\n          console.log(`Usando bucket alternativo '${bucketName}' para la subida.`);\n        }\n      } catch (fallbackError) {\n        console.error(`No se pudo usar ningún bucket para la subida:`, fallbackError);\n        throw createAppError(\n          ErrorType.UPLOAD,\n          `No se pudo preparar un bucket para subir documentos. Contacte al administrador.`,\n          { originalError: bucketError }\n        );\n      }\n    }\n    \n    const storage = getStorage();\n    const uploadedDocs: Array<Omit<ClientDocument & { url: string }, 'file'>> = [];\n    const failedDocs: Array<{name: string, error: any}> = [];\n\n    // Filter out docs with invalid or missing files\n    const validDocs = documents.filter(doc => \n      doc && doc.file && doc.file instanceof File && doc.category && doc.name\n    );\n    console.log(`Documentos válidos para subida: ${validDocs.length} de ${documents.length}`);\n\n    if (validDocs.length === 0) {\n      console.warn(`No hay documentos válidos para subir. Se requiere archivo, categoría y nombre.`);\n      return [];\n    }\n\n    for (let docIndex = 0; docIndex < validDocs.length; docIndex++) {\n      const doc = validDocs[docIndex];\n      let fileUrl = '';\n      let success = false;\n      let retries = 0;\n      let lastError = null;\n\n      console.log(`Procesando documento ${docIndex + 1}/${validDocs.length}: \"${doc.name}\" (${doc.file.size} bytes)`);\n\n      while (!success && retries <= maxRetries) {\n        retries++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileNameSafe = doc.file.name.replace(/[^a-zA-Z0-9.-]/g, '_'); // Sanitizar nombre de archivo\n          const fileName = `${timestamp}_${fileNameSafe}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n          console.log(`Intento ${retries}/${maxRetries+1}: Subiendo \"${doc.name}\" a ${bucketName}/${filePath}`);\n\n          // Upload the file\n          const { data, error } = await storage\n            .from(bucketName)\n            .upload(filePath, doc.file, {\n              cacheControl: '3600',\n              upsert: true, // Cambiar a true para sobrescribir si existe\n            });\n\n          if (error) {\n            console.error(`Error al subir archivo \"${doc.name}\" (intento ${retries}/${maxRetries+1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const { data: urlData } = storage\n            .from(bucketName)\n            .getPublicUrl(filePath);\n\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`✅ Documento \"${doc.name}\" subido exitosamente a ${bucketName}/${filePath}`);\n        } catch (error) {\n          lastError = error;\n          \n          // Imprimir detalles adicionales del error para diagnóstico\n          if (error instanceof Error) {\n            console.error(`Detalles del error: ${error.message}`);\n            if ((error as any).stack) {\n              console.error(`Stack: ${(error as any).stack}`);\n            }\n          }\n          \n          // Si no es el último intento, esperar antes de reintentar\n          if (retries <= maxRetries) {\n            const waitTime = Math.pow(2, retries-1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar la subida...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`❌ Falló la subida de \"${doc.name}\" después de ${retries} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            \n            // Create a proper AppError and log it\n            const uploadError = createAppError(\n              ErrorType.UPLOAD,\n              `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries+1} intentos`,\n              {\n                documentName: doc.name,\n                clientId,\n                category: doc.category,\n                attempts: retries\n              },\n              error\n            );\n            \n            logError(uploadError, 'uploadClientDocuments');\n          }\n        }\n      }\n\n      if (success) {\n        // Create document without the file property\n        const { file, ...docWithoutFile } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n\n    if (failedDocs.length > 0) {\n      console.warn(`⚠️ ${failedDocs.length} documentos fallaron al subirse de un total de ${validDocs.length}:`, failedDocs);\n    }\n    \n    console.log(`📊 Resumen: ${uploadedDocs.length} documentos subidos exitosamente, ${failedDocs.length} fallidos.`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('❌ Error general en uploadClientDocuments:', error);\n    \n    // Proporcionar un mensaje de error más descriptivo basado en el tipo de error\n    let errorMessage = 'Error al subir documentos';\n    if (error instanceof Error) {\n      errorMessage = error.message;\n    } else if (typeof error === 'object' && error !== null && 'message' in error) {\n      errorMessage = (error as any).message || errorMessage;\n    }\n    \n    throw createAppError(\n      ErrorType.UPLOAD,\n      errorMessage,\n      { clientId, error }\n    );\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}