{"ast":null,"code":"/**\n * Database utilities for direct data access\n */\n\nimport { supabase } from '../lib/supabaseClient';\n\n// Valores de autenticación de Supabase\nconst SUPABASE_URL = 'https://ydnygntfkrleiseuciwq.supabase.co';\nconst SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnlnbnRma3JsZWlzZXVjaXdxIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczOTk5MjQwNiwiZXhwIjoyMDU1NTY4NDA2fQ.TwhEGW9DK4DTQQRquT6Z9UW8T8UjLX-hp9uKdRjWAhs';\n\n// Use the imported supabase client instead of creating a new one\n// This helps ensure we only have one client instance across the app\n\n// Add a cache for approval status to persist data during connection issues\nconst approvalStatusCache = new Map();\n\n// Track connection status\nlet supabaseConnected = true;\nlet lastConnectionAttempt = 0;\nconst CONNECTION_RETRY_INTERVAL = 30000; // 30 seconds\n\n// Helper function to parse SQL query\nexport const parseQuery = query => {\n  const queryLower = query.toLowerCase();\n\n  // Detect query type\n  let type = 'select';\n  if (queryLower.startsWith('insert')) type = 'insert';\n  if (queryLower.startsWith('update')) type = 'update';\n  if (queryLower.startsWith('delete')) type = 'delete';\n\n  // Extract table name\n  let table = '';\n  if (type === 'select') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  } else if (type === 'insert') {\n    const intoMatch = queryLower.match(/into\\s+([a-z0-9_]+)/i);\n    if (intoMatch && intoMatch[1]) table = intoMatch[1];\n  } else if (type === 'update') {\n    const updateMatch = queryLower.match(/update\\s+([a-z0-9_]+)/i);\n    if (updateMatch && updateMatch[1]) table = updateMatch[1];\n  } else if (type === 'delete') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  }\n\n  // Extract conditions from WHERE clause (simplified)\n  let conditions = {};\n  const whereMatch = queryLower.match(/where\\s+(.*?)(?:order by|group by|limit|$)/i);\n  if (whereMatch && whereMatch[1]) {\n    const whereClause = whereMatch[1].trim();\n\n    // For simpler queries, try to parse conditions\n    // This is a very basic implementation and might not work for complex conditions\n    const condPairs = whereClause.split(/\\s+and\\s+/i);\n    condPairs.forEach(pair => {\n      const equalMatch = pair.match(/([a-z0-9_]+)\\s*=\\s*'([^']+)'/i);\n      if (equalMatch) {\n        conditions[equalMatch[1]] = equalMatch[2];\n      }\n    });\n  }\n  return {\n    table,\n    type,\n    conditions\n  };\n};\n\n// Execute query specifically with Supabase\nexport const executeSupabaseQuery = async (table, type, conditions, originalQuery) => {\n  if (!table) {\n    throw new Error('Table name is required for Supabase query execution');\n  }\n  try {\n    let result;\n    if (type === 'select') {\n      // For select queries, use Supabase query builder\n      let query = supabase.from(table).select('*');\n\n      // Apply conditions if available\n      if (conditions && Object.keys(conditions).length > 0) {\n        Object.entries(conditions).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n      const {\n        data,\n        error\n      } = await query;\n      if (error) throw error;\n      result = data || [];\n    } else {\n      // For other query types, we'd need more complex logic\n      // This is a simplified implementation\n      console.warn('Non-SELECT queries are not fully implemented in executeSupabaseQuery');\n      throw new Error('Only SELECT queries are supported in this implementation');\n    }\n    return result;\n  } catch (error) {\n    console.error('Supabase query execution error:', error);\n    throw error;\n  }\n};\n\n// Execute query with MCP server\nexport const executeMcpQuery = async query => {\n  try {\n    // Here we would implement the logic to send the query to the MCP server\n    // For now, this is a placeholder that simulates an MCP call\n    const response = await fetch('/api/mcp-query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`MCP server responded with status: ${response.status}`);\n    }\n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    console.error('MCP server connection error:', error);\n    throw error;\n  }\n};\n\n// Helper function to check and potentially reconnect to Supabase\nexport const ensureSupabaseConnection = async () => {\n  const now = Date.now();\n\n  // Only retry connection every 30 seconds to avoid too many reconnect attempts\n  if (!supabaseConnected && now - lastConnectionAttempt > CONNECTION_RETRY_INTERVAL) {\n    console.log('Attempting to reconnect to Supabase...');\n    lastConnectionAttempt = now;\n    try {\n      // Simple health check query\n      const {\n        data,\n        error\n      } = await supabase.from('applications').select('count(*)', {\n        count: 'exact'\n      }).limit(1);\n      if (error) {\n        console.error('Supabase reconnection failed:', error);\n        supabaseConnected = false;\n        return false;\n      }\n      console.log('Successfully reconnected to Supabase');\n      supabaseConnected = true;\n      return true;\n    } catch (error) {\n      console.error('Supabase reconnection error:', error);\n      supabaseConnected = false;\n      return false;\n    }\n  }\n  return supabaseConnected;\n};\n\n// Function to execute a database query\nexport const executeQuery = async query => {\n  // Log the query for debugging\n  console.log('Original SQL query:', query);\n\n  // Try to ensure we have a connection first if we're not connected\n  if (!supabaseConnected) {\n    await ensureSupabaseConnection();\n  }\n  try {\n    // First, try to execute with Supabase\n    const {\n      table,\n      type,\n      conditions\n    } = parseQuery(query);\n    if (!table) {\n      console.error('Could not determine table from query:', query);\n      throw new Error('Invalid query: Could not determine table');\n    }\n    console.log('Extracted table name:', `'${table}'`);\n\n    // For approval status queries, check the cache first in case of connection issues\n    if (table === 'applications' && query.includes('approved_by_advisor') && query.includes('WHERE id =')) {\n      // Extract the application ID from the query\n      const idMatch = query.match(/WHERE id = '([^']+)'/);\n      if (idMatch && idMatch[1]) {\n        const appId = idMatch[1];\n        try {\n          // Attempt to execute the query normally\n          const result = await executeSupabaseQuery(table, type, conditions, query);\n\n          // If successful, update the cache\n          if (result && result.length > 0) {\n            approvalStatusCache.set(appId, result[0]);\n            console.log(`Updated approval cache for ${appId}`);\n          }\n          return result;\n        } catch (error) {\n          // If query fails but we have cached data, use it\n          if (approvalStatusCache.has(appId)) {\n            console.log(`Using cached approval data for ${appId} due to connection error`);\n            return [approvalStatusCache.get(appId)];\n          }\n          // Otherwise, rethrow the error\n          throw error;\n        }\n      }\n    }\n\n    // Execute the query through Supabase\n    const result = await executeSupabaseQuery(table, type, conditions, query);\n\n    // If we get here, connection is working\n    supabaseConnected = true;\n    return result;\n  } catch (error) {\n    // Mark connection as potentially broken\n    supabaseConnected = false;\n    console.error('Error in executeQuery:', error);\n    console.log('Using fallback query execution for:', query);\n\n    // For select queries with the MCP server\n    try {\n      return await executeMcpQuery(query);\n    } catch (mcpError) {\n      console.error('MCP server query failed:', mcpError);\n\n      // If this is specifically an approval status query and both Supabase and MCP fail\n      if (query.includes('SELECT') && query.includes('approved_by_advisor') && query.includes('approved_by_company')) {\n        console.warn('Both Supabase and MCP failed for approval status query. Returning default values.');\n        return [{\n          approved_by_advisor: false,\n          approved_by_company: false,\n          approval_date_advisor: null,\n          approval_date_company: null\n        }];\n      }\n      throw mcpError;\n    }\n  }\n};\n\n// Function to reinitialize Supabase client in case of connection issues\nexport const reinitializeSupabaseClient = () => {\n  console.log('Reinitializing Supabase client connection...');\n  // Since we're now using the imported client, we can't recreate it here,\n  // but we can test the connection to effectively reinitialize the session\n  return testSupabaseConnection().then(connected => {\n    supabaseConnected = connected;\n    return supabase;\n  });\n};\n\n// Function to test the Supabase connection\nexport const testSupabaseConnection = async () => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('applications').select('count(*)', {\n      count: 'exact'\n    }).limit(1);\n    if (error) {\n      console.error('Supabase connection test failed:', error);\n      return false;\n    }\n    console.log('Supabase connection test successful');\n    return true;\n  } catch (error) {\n    console.error('Supabase connection test error:', error);\n    return false;\n  }\n};\n\n// Export supabase client for direct usage\nexport { supabase };\n\n/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = value => {\n  if (!value) return '';\n\n  // Reemplazar comillas simples por dos comillas simples (estándar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = date => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = conditions => {\n  const clauses = [];\n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => typeof v === 'string' ? `'${escapeSqlString(v)}'` : v);\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n};\n\n/**\n * Fetches approval statuses for multiple applications in a single batch query\n * @param ids Array of application IDs to fetch approval statuses for\n * @returns A Map with application IDs as keys and approval data as values\n */\nexport const fetchApprovalsBatch = async ids => {\n  if (!ids || ids.length === 0) {\n    return new Map();\n  }\n  try {\n    console.log(`Fetching approval statuses in batch for ${ids.length} applications`);\n\n    // Execute a single query for all IDs instead of individual queries\n    const {\n      data,\n      error\n    } = await supabase.from('applications').select('id, approved_by_advisor, approved_by_company, approval_date_advisor, approval_date_company').in('id', ids);\n    if (error) {\n      console.error('Error fetching approval statuses in batch:', error);\n      throw error;\n    }\n    if (!data || data.length === 0) {\n      console.warn('No approval data returned for batch query');\n      return new Map();\n    }\n    console.log(`Successfully fetched ${data.length} approval statuses in batch`);\n\n    // Store results in the cache\n    data.forEach(item => {\n      const cachedResultKey = `approval_status_${item.id}`;\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(item));\n      } catch (e) {\n        // Ignore storage errors\n      }\n    });\n\n    // Return a Map for easy lookup by ID\n    return new Map(data.map(item => [item.id, {\n      approvedByAdvisor: item.approved_by_advisor || false,\n      approvedByCompany: item.approved_by_company || false,\n      approvalDateAdvisor: item.approval_date_advisor,\n      approvalDateCompany: item.approval_date_company\n    }]));\n  } catch (error) {\n    console.error('Error in fetchApprovalsBatch:', error);\n    // Return empty Map on error\n    return new Map();\n  }\n};\n\n// Initialize connection status check\nsetTimeout(() => {\n  ensureSupabaseConnection();\n}, 1000);","map":{"version":3,"names":["supabase","SUPABASE_URL","SERVICE_ROLE_KEY","approvalStatusCache","Map","supabaseConnected","lastConnectionAttempt","CONNECTION_RETRY_INTERVAL","parseQuery","query","queryLower","toLowerCase","type","startsWith","table","fromMatch","match","intoMatch","updateMatch","conditions","whereMatch","whereClause","trim","condPairs","split","forEach","pair","equalMatch","executeSupabaseQuery","originalQuery","Error","result","from","select","Object","keys","length","entries","key","value","eq","data","error","console","warn","executeMcpQuery","response","fetch","method","headers","body","JSON","stringify","ok","status","json","ensureSupabaseConnection","now","Date","log","count","limit","executeQuery","includes","idMatch","appId","set","has","get","mcpError","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","reinitializeSupabaseClient","testSupabaseConnection","then","connected","escapeSqlString","replace","formatDateForSql","date","toISOString","objectToSqlWhere","clauses","undefined","push","Array","isArray","formattedValues","map","v","join","fetchApprovalsBatch","ids","in","item","cachedResultKey","id","sessionStorage","setItem","e","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","setTimeout"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/databaseUtils.ts"],"sourcesContent":["/**\n * Database utilities for direct data access\n */\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { TABLES } from './constants/tables';\nimport { supabase } from '../lib/supabaseClient';\n\n// Valores de autenticación de Supabase\nconst SUPABASE_URL = 'https://ydnygntfkrleiseuciwq.supabase.co';\nconst SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkbnlnbnRma3JsZWlzZXVjaXdxIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTczOTk5MjQwNiwiZXhwIjoyMDU1NTY4NDA2fQ.TwhEGW9DK4DTQQRquT6Z9UW8T8UjLX-hp9uKdRjWAhs';\n\n// Use the imported supabase client instead of creating a new one\n// This helps ensure we only have one client instance across the app\n\n// Add a cache for approval status to persist data during connection issues\nconst approvalStatusCache = new Map<string, any>();\n\n// Track connection status\nlet supabaseConnected = true;\nlet lastConnectionAttempt = 0;\nconst CONNECTION_RETRY_INTERVAL = 30000; // 30 seconds\n\n// Helper function to parse SQL query\nexport const parseQuery = (query: string): { table: string; type: string; conditions: any } => {\n  const queryLower = query.toLowerCase();\n  \n  // Detect query type\n  let type = 'select';\n  if (queryLower.startsWith('insert')) type = 'insert';\n  if (queryLower.startsWith('update')) type = 'update';\n  if (queryLower.startsWith('delete')) type = 'delete';\n  \n  // Extract table name\n  let table = '';\n  if (type === 'select') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  } else if (type === 'insert') {\n    const intoMatch = queryLower.match(/into\\s+([a-z0-9_]+)/i);\n    if (intoMatch && intoMatch[1]) table = intoMatch[1];\n  } else if (type === 'update') {\n    const updateMatch = queryLower.match(/update\\s+([a-z0-9_]+)/i);\n    if (updateMatch && updateMatch[1]) table = updateMatch[1];\n  } else if (type === 'delete') {\n    const fromMatch = queryLower.match(/from\\s+([a-z0-9_]+)/i);\n    if (fromMatch && fromMatch[1]) table = fromMatch[1];\n  }\n  \n  // Extract conditions from WHERE clause (simplified)\n  let conditions: any = {};\n  const whereMatch = queryLower.match(/where\\s+(.*?)(?:order by|group by|limit|$)/i);\n  if (whereMatch && whereMatch[1]) {\n    const whereClause = whereMatch[1].trim();\n    \n    // For simpler queries, try to parse conditions\n    // This is a very basic implementation and might not work for complex conditions\n    const condPairs = whereClause.split(/\\s+and\\s+/i);\n    condPairs.forEach(pair => {\n      const equalMatch = pair.match(/([a-z0-9_]+)\\s*=\\s*'([^']+)'/i);\n      if (equalMatch) {\n        conditions[equalMatch[1]] = equalMatch[2];\n      }\n    });\n  }\n  \n  return { table, type, conditions };\n};\n\n// Execute query specifically with Supabase\nexport const executeSupabaseQuery = async (\n  table: string, \n  type: string, \n  conditions: any, \n  originalQuery: string\n): Promise<any[]> => {\n  if (!table) {\n    throw new Error('Table name is required for Supabase query execution');\n  }\n  \n  try {\n    let result;\n    \n    if (type === 'select') {\n      // For select queries, use Supabase query builder\n      let query = supabase.from(table).select('*');\n      \n      // Apply conditions if available\n      if (conditions && Object.keys(conditions).length > 0) {\n        Object.entries(conditions).forEach(([key, value]) => {\n          query = query.eq(key, value);\n        });\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) throw error;\n      result = data || [];\n    } else {\n      // For other query types, we'd need more complex logic\n      // This is a simplified implementation\n      console.warn('Non-SELECT queries are not fully implemented in executeSupabaseQuery');\n      throw new Error('Only SELECT queries are supported in this implementation');\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Supabase query execution error:', error);\n    throw error;\n  }\n};\n\n// Execute query with MCP server\nexport const executeMcpQuery = async (query: string): Promise<any[]> => {\n  try {\n    // Here we would implement the logic to send the query to the MCP server\n    // For now, this is a placeholder that simulates an MCP call\n    const response = await fetch('/api/mcp-query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`MCP server responded with status: ${response.status}`);\n    }\n    \n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    console.error('MCP server connection error:', error);\n    throw error;\n  }\n};\n\n// Helper function to check and potentially reconnect to Supabase\nexport const ensureSupabaseConnection = async (): Promise<boolean> => {\n  const now = Date.now();\n  \n  // Only retry connection every 30 seconds to avoid too many reconnect attempts\n  if (!supabaseConnected && (now - lastConnectionAttempt) > CONNECTION_RETRY_INTERVAL) {\n    console.log('Attempting to reconnect to Supabase...');\n    lastConnectionAttempt = now;\n    \n    try {\n      // Simple health check query\n      const { data, error } = await supabase.from('applications').select('count(*)', { count: 'exact' }).limit(1);\n      \n      if (error) {\n        console.error('Supabase reconnection failed:', error);\n        supabaseConnected = false;\n        return false;\n      }\n      \n      console.log('Successfully reconnected to Supabase');\n      supabaseConnected = true;\n      return true;\n    } catch (error) {\n      console.error('Supabase reconnection error:', error);\n      supabaseConnected = false;\n      return false;\n    }\n  }\n  \n  return supabaseConnected;\n};\n\n// Function to execute a database query\nexport const executeQuery = async (query: string): Promise<any[]> => {\n  // Log the query for debugging\n  console.log('Original SQL query:', query);\n  \n  // Try to ensure we have a connection first if we're not connected\n  if (!supabaseConnected) {\n    await ensureSupabaseConnection();\n  }\n  \n  try {\n    // First, try to execute with Supabase\n    const { table, type, conditions } = parseQuery(query);\n    \n    if (!table) {\n      console.error('Could not determine table from query:', query);\n      throw new Error('Invalid query: Could not determine table');\n    }\n    \n    console.log('Extracted table name:', `'${table}'`);\n    \n    // For approval status queries, check the cache first in case of connection issues\n    if (table === 'applications' && query.includes('approved_by_advisor') && query.includes('WHERE id =')) {\n      // Extract the application ID from the query\n      const idMatch = query.match(/WHERE id = '([^']+)'/);\n      if (idMatch && idMatch[1]) {\n        const appId = idMatch[1];\n        \n        try {\n          // Attempt to execute the query normally\n          const result = await executeSupabaseQuery(table, type, conditions, query);\n          \n          // If successful, update the cache\n          if (result && result.length > 0) {\n            approvalStatusCache.set(appId, result[0]);\n            console.log(`Updated approval cache for ${appId}`);\n          }\n          \n          return result;\n        } catch (error) {\n          // If query fails but we have cached data, use it\n          if (approvalStatusCache.has(appId)) {\n            console.log(`Using cached approval data for ${appId} due to connection error`);\n            return [approvalStatusCache.get(appId)];\n          }\n          // Otherwise, rethrow the error\n          throw error;\n        }\n      }\n    }\n    \n    // Execute the query through Supabase\n    const result = await executeSupabaseQuery(table, type, conditions, query);\n    \n    // If we get here, connection is working\n    supabaseConnected = true;\n    \n    return result;\n  } catch (error) {\n    // Mark connection as potentially broken\n    supabaseConnected = false;\n    \n    console.error('Error in executeQuery:', error);\n    console.log('Using fallback query execution for:', query);\n    \n    // For select queries with the MCP server\n    try {\n      return await executeMcpQuery(query);\n    } catch (mcpError) {\n      console.error('MCP server query failed:', mcpError);\n      \n      // If this is specifically an approval status query and both Supabase and MCP fail\n      if (query.includes('SELECT') && \n          query.includes('approved_by_advisor') && \n          query.includes('approved_by_company')) {\n        \n        console.warn('Both Supabase and MCP failed for approval status query. Returning default values.');\n        return [{\n          approved_by_advisor: false,\n          approved_by_company: false,\n          approval_date_advisor: null,\n          approval_date_company: null\n        }];\n      }\n      \n      throw mcpError;\n    }\n  }\n};\n\n// Function to reinitialize Supabase client in case of connection issues\nexport const reinitializeSupabaseClient = () => {\n  console.log('Reinitializing Supabase client connection...');\n  // Since we're now using the imported client, we can't recreate it here,\n  // but we can test the connection to effectively reinitialize the session\n  return testSupabaseConnection().then(connected => {\n    supabaseConnected = connected;\n    return supabase;\n  });\n};\n\n// Function to test the Supabase connection\nexport const testSupabaseConnection = async (): Promise<boolean> => {\n  try {\n    const { data, error } = await supabase.from('applications').select('count(*)', { count: 'exact' }).limit(1);\n    if (error) {\n      console.error('Supabase connection test failed:', error);\n      return false;\n    }\n    console.log('Supabase connection test successful');\n    return true;\n  } catch (error) {\n    console.error('Supabase connection test error:', error);\n    return false;\n  }\n};\n\n// Export supabase client for direct usage\nexport { supabase };\n\n/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = (value: string): string => {\n  if (!value) return '';\n  \n  // Reemplazar comillas simples por dos comillas simples (estándar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = (date: Date): string => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = (conditions: Record<string, any>): string => {\n  const clauses = [];\n  \n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    \n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => \n        typeof v === 'string' ? `'${escapeSqlString(v)}'` : v\n      );\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  \n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n}; \n\n/**\n * Fetches approval statuses for multiple applications in a single batch query\n * @param ids Array of application IDs to fetch approval statuses for\n * @returns A Map with application IDs as keys and approval data as values\n */\nexport const fetchApprovalsBatch = async (ids: string[]) => {\n  if (!ids || ids.length === 0) {\n    return new Map();\n  }\n\n  try {\n    console.log(`Fetching approval statuses in batch for ${ids.length} applications`);\n    \n    // Execute a single query for all IDs instead of individual queries\n    const { data, error } = await supabase\n      .from('applications')\n      .select('id, approved_by_advisor, approved_by_company, approval_date_advisor, approval_date_company')\n      .in('id', ids);\n    \n    if (error) {\n      console.error('Error fetching approval statuses in batch:', error);\n      throw error;\n    }\n    \n    if (!data || data.length === 0) {\n      console.warn('No approval data returned for batch query');\n      return new Map();\n    }\n    \n    console.log(`Successfully fetched ${data.length} approval statuses in batch`);\n    \n    // Store results in the cache\n    data.forEach(item => {\n      const cachedResultKey = `approval_status_${item.id}`;\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(item));\n      } catch (e) {\n        // Ignore storage errors\n      }\n    });\n    \n    // Return a Map for easy lookup by ID\n    return new Map(data.map(item => [\n      item.id, \n      {\n        approvedByAdvisor: item.approved_by_advisor || false,\n        approvedByCompany: item.approved_by_company || false,\n        approvalDateAdvisor: item.approval_date_advisor,\n        approvalDateCompany: item.approval_date_company\n      }\n    ]));\n  } catch (error) {\n    console.error('Error in fetchApprovalsBatch:', error);\n    // Return empty Map on error\n    return new Map();\n  }\n}\n\n// Initialize connection status check\nsetTimeout(() => {\n  ensureSupabaseConnection();\n}, 1000); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}