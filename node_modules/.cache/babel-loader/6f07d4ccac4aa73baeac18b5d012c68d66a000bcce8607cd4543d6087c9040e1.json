{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = file => {\n  // Allowed MIME types\n  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/heic', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (document, folder, attempt = 1) => {\n  const file = document.file;\n  if (!isValidDocument(file)) {\n    throw createAppError(ErrorType.VALIDATION, 'Invalid document format or size', {\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size\n    });\n  }\n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n\n    // Upload the file\n    const {\n      error: uploadError\n    } = await supabase.storage.from('documents').upload(filePath, file);\n    if (uploadError) {\n      throw createAppError(ErrorType.UPLOAD, `Error uploading document: ${uploadError.message}`, {\n        filePath,\n        attempt\n      }, uploadError);\n    }\n\n    // Get public URL for the uploaded file\n    const {\n      data: publicUrlData\n    } = supabase.storage.from('documents').getPublicUrl(filePath);\n\n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', {\n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n\n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n\n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (documents, folder) => {\n  const uploadedDocs = [];\n  const failedDocs = [];\n\n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(uploadDocumentToStorage(document, folder), 'uploadDocuments');\n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({\n        document,\n        error\n      });\n    }\n  }\n  return {\n    uploadedDocs,\n    failedDocs\n  };\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (clientId, documents, maxRetries = 2) => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n  const storage = getStorage();\n  const uploadedDocs = [];\n\n  // Filter out documents without files\n  const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n  for (const doc of validDocuments) {\n    let fileUrl = '';\n    let success = false;\n    let attempts = 0;\n    while (!success && attempts <= maxRetries) {\n      attempts++;\n      try {\n        // Construct a unique file name to avoid collisions\n        const timestamp = new Date().getTime();\n        const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n        const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n        // Upload the file\n        const {\n          data,\n          error\n        } = await storage.from('client-documents').upload(filePath, doc.file, {\n          cacheControl: '3600',\n          upsert: false\n        });\n        if (error) throw error;\n\n        // Get the public URL\n        const {\n          data: urlData\n        } = storage.from('client-documents').getPublicUrl(filePath);\n        fileUrl = urlData.publicUrl;\n        success = true;\n      } catch (error) {\n        // Log error and retry if under the max attempts\n        if (attempts > maxRetries) {\n          logError({\n            message: `Error al subir documento después de ${maxRetries} intentos`,\n            error,\n            data: {\n              documentName: doc.file.name,\n              clientId\n            }\n          }, ErrorType.UPLOAD);\n        }\n      }\n    }\n    if (success) {\n      uploadedDocs.push({\n        ...doc,\n        url: fileUrl,\n        file: undefined\n      });\n    }\n  }\n  return uploadedDocs;\n};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","getStorage","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","uploadClientDocuments","clientId","maxRetries","Error","Array","isArray","length","validDocuments","filter","doc","category","fileUrl","success","attempts","timestamp","getTime","replace","cacheControl","upsert","urlData","documentName","undefined"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\nimport { ClientDocument } from '../types/client';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from('documents')\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from('documents')\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n\n  const storage = getStorage();\n  const uploadedDocs: Array<Omit<ClientDocument & { url: string }, 'file'>> = [];\n\n  // Filter out documents without files\n  const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n\n  for (const doc of validDocuments) {\n    let fileUrl = '';\n    let success = false;\n    let attempts = 0;\n\n    while (!success && attempts <= maxRetries) {\n      attempts++;\n      try {\n        // Construct a unique file name to avoid collisions\n        const timestamp = new Date().getTime();\n        const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n        const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n        // Upload the file\n        const { data, error } = await storage\n          .from('client-documents')\n          .upload(filePath, doc.file, {\n            cacheControl: '3600',\n            upsert: false,\n          });\n\n        if (error) throw error;\n\n        // Get the public URL\n        const { data: urlData } = storage\n          .from('client-documents')\n          .getPublicUrl(filePath);\n\n        fileUrl = urlData.publicUrl;\n        success = true;\n      } catch (error) {\n        // Log error and retry if under the max attempts\n        if (attempts > maxRetries) {\n          logError({\n            message: `Error al subir documento después de ${maxRetries} intentos`,\n            error,\n            data: { documentName: doc.file.name, clientId },\n          }, ErrorType.UPLOAD);\n        }\n      }\n    }\n\n    if (success) {\n      uploadedDocs.push({\n        ...doc,\n        url: fileUrl,\n        file: undefined,\n      } as Omit<ClientDocument & { url: string }, 'file'>);\n    }\n  }\n\n  return uploadedDocs;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}