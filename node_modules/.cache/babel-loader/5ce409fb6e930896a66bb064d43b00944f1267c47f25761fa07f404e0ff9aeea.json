{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase } from '../services/supabaseService';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\n\n// Define application interface\n\n// Get all applications with filters\nexport const getApplications = async (filters, entityFilter) => {\n  try {\n    console.log(\"getApplications called with filters:\", filters);\n\n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase.from(TABLES.APPLICATIONS).select('*');\n\n    // Aplicar filtro de entidad\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n\n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n\n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        console.log(`Applying application_type filter: ${filters.application_type}`);\n        query = query.eq('application_type', filters.application_type);\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n\n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n\n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', {\n      ascending: false\n    });\n\n    // Ejecutar la consulta\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n    console.log(`Retrieved ${data.length} applications from database`);\n\n    // Log the types of applications we retrieved\n    const types = new Set(data.map(app => app.application_type));\n    console.log('DB application types:', Array.from(types));\n\n    // Double-check if the filter was applied correctly\n    if (filters !== null && filters !== void 0 && filters.application_type) {\n      const matchingApps = data.filter(app => app.application_type === filters.application_type);\n      console.log(`After DB query: ${matchingApps.length} of ${data.length} apps match type '${filters.application_type}'`);\n    }\n\n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map(app => {\n      // Obtener el estado mapeado\n      const mappedStatus = mapStatusFromDB(app.status);\n\n      // Asegurar que los estados específicos por rol estén inicializados\n      // Si no existen, usar el estado principal\n      const advisorStatus = app.advisor_status ? mapStatusFromDB(app.advisor_status) : mappedStatus;\n      const companyStatus = app.company_status ? mapStatusFromDB(app.company_status) : mappedStatus;\n      const globalStatus = app.global_status ? mapStatusFromDB(app.global_status) : mappedStatus;\n      return {\n        id: app.id,\n        client_id: app.source_id || \"\",\n        company_id: app.company_id || \"\",\n        assigned_to: app.assigned_to || \"\",\n        application_type: app.application_type || \"\",\n        requested_amount: parseFloat(app.amount) || 0,\n        status: mappedStatus,\n        // Añadir los estados específicos para cada rol\n        advisor_status: advisorStatus,\n        company_status: companyStatus,\n        global_status: globalStatus,\n        created_at: app.created_at,\n        updated_at: app.updated_at,\n        client_name: app.client_name,\n        client_email: app.client_email,\n        company_name: app.company_name,\n        advisor_name: \"\",\n        // Este campo no está en la BD\n        approved_by_advisor: app.approved_by_advisor || false,\n        approved_by_company: app.approved_by_company || false,\n        approval_date_advisor: app.approval_date_advisor,\n        approval_date_company: app.approval_date_company,\n        // Mapeo directo de campos adicionales de la BD\n        client_phone: app.client_phone,\n        client_address: app.client_address,\n        dni: app.dni,\n        amount: parseFloat(app.amount) || 0,\n        term: app.term ? parseInt(app.term) : undefined,\n        interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n        monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n        // Campos para tipo de financiamiento y productos\n        financing_type: app.financing_type || null,\n        product_url: app.product_url || null,\n        product_title: app.product_title || null,\n        product_image: app.product_image || null\n      };\n    });\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = dbStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n\n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => status.toLowerCase() === normalizedStatus);\n  if (directMapping) {\n    return directMapping;\n  }\n\n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return statusMap[normalizedStatus] || APPLICATION_STATUS.NEW;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async application => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ');\n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id, updates, entityFilter) => {\n  const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`).join(', ');\n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  query += ' RETURNING *';\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (id, status, comment, user_id, entityFilter) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, {\n    entityFilter\n  });\n\n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase.from(TABLES.APPLICATIONS).select('status, assigned_to, company_id').eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: currentStateData,\n      error: fetchError\n    } = await query;\n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, {\n        entityFilter\n      });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n\n    // 2. Update the application using Supabase client\n    const updateData = {\n      status: status,\n      status_previous: currentStatus\n    };\n\n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    let updateQuery = supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: updatedApp,\n      error: updateError\n    } = await updateQuery.select();\n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n\n    // 3. Add to history\n    const historyComment = currentStatus !== status ? `${comment} (Cambio de estado: ${currentStatus} → ${status})` : comment;\n    try {\n      const {\n        error: historyError\n      } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n        application_id: id,\n        status: status,\n        comment: historyComment,\n        created_by: user_id\n      });\n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (id, comment, advisor_id, entityFilter) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id)) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n\n    // Primero obtenemos la aplicación para verificar el estado de la aprobación de la empresa\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).eq('assigned_to', advisor_id).single();\n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Preparar los campos a actualizar\n    const updateData = {\n      approved_by_advisor: true,\n      approval_date_advisor: new Date().toISOString(),\n      advisor_status: APPLICATION_STATUS.APPROVED,\n      // Siempre actualizar el estado específico del asesor\n      updated_at: new Date().toISOString()\n    };\n\n    // Solo actualizar el estado global si la empresa ya ha aprobado\n    if (application.approved_by_company === true) {\n      // Cuando ambos aprueban, automáticamente pasa a POR_DISPERSAR\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n\n    // Actualizar la aplicación\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id).eq('assigned_to', advisor_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      previous_status: application.advisor_status || application.status,\n      new_status: APPLICATION_STATUS.APPROVED,\n      status_field: 'advisor_status',\n      changed_by: advisor_id,\n      comments: comment || 'Solicitud aprobada por asesor',\n      changed_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Primero obtenemos la aplicación para verificar el estado de la aprobación del asesor\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).eq('company_id', company_id).single();\n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Preparar los campos a actualizar\n    const updateData = {\n      approved_by_company: true,\n      approval_date_company: new Date().toISOString(),\n      company_status: APPLICATION_STATUS.APPROVED,\n      // Siempre actualizar el estado específico de la empresa\n      updated_at: new Date().toISOString()\n    };\n\n    // Solo actualizar el estado global si el asesor ya ha aprobado\n    if (application.approved_by_advisor === true) {\n      // Cuando ambos aprueban, automáticamente pasa a POR_DISPERSAR\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n\n    // Actualizar la aplicación\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      previous_status: application.company_status || application.status,\n      new_status: APPLICATION_STATUS.APPROVED,\n      status_field: 'company_status',\n      changed_by: company_admin_id,\n      comments: comment || 'Solicitud aprobada por empresa',\n      changed_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Primero obtenemos la aplicación para verificar su estado actual\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).eq('company_id', company_id).single();\n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n\n    // Preparar los campos a actualizar\n    const updateData = {\n      approved_by_company: false,\n      approval_date_company: null,\n      company_status: APPLICATION_STATUS.IN_REVIEW,\n      // Solo cambiamos el estado de la empresa\n      updated_at: new Date().toISOString()\n    };\n\n    // Solo actualizar el estado global si estaba basado en la aprobación completa\n    if (application.status === APPLICATION_STATUS.APPROVED && application.advisor_status === APPLICATION_STATUS.APPROVED && application.company_status === APPLICATION_STATUS.APPROVED) {\n      // Revertir al estado de revisión ya que una parte retiró su aprobación\n      updateData.status = APPLICATION_STATUS.IN_REVIEW;\n      updateData.global_status = APPLICATION_STATUS.IN_REVIEW;\n    }\n\n    // Actualizar la aplicación\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      previous_status: application.company_status || application.status,\n      new_status: APPLICATION_STATUS.IN_REVIEW,\n      status_field: 'company_status',\n      changed_by: company_admin_id,\n      comments: comment || 'Aprobación de empresa cancelada',\n      changed_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (id, entityFilter) => {\n  try {\n    // Usar Supabase client para obtener los datos\n    let query = supabase.from(TABLES.APPLICATIONS).select(`\n        approved_by_advisor, \n        approved_by_company, \n        approval_date_advisor, \n        approval_date_company,\n        status,\n        advisor_status,\n        company_status,\n        global_status\n      `).eq('id', id);\n\n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data,\n      error\n    } = await query.single();\n    if (error) {\n      console.error(`Error obteniendo estado de aprobación para ${id}:`, error);\n\n      // En caso de error, devolvemos valor indefinido para que la UI maneje el caso correctamente\n      return undefined;\n    }\n    if (!data) {\n      console.warn(`Solicitud ${id} no encontrada para obtener estado de aprobación`);\n      return undefined;\n    }\n\n    // Verificar si la solicitud está totalmente aprobada (ambas partes)\n    const isFullyApproved = data.approved_by_advisor === true && data.approved_by_company === true;\n    return {\n      approvedByAdvisor: data.approved_by_advisor === true,\n      approvedByCompany: data.approved_by_company === true,\n      approvalDateAdvisor: data.approval_date_advisor,\n      approvalDateCompany: data.approval_date_company,\n      isFullyApproved: isFullyApproved,\n      // Incluir estados para que la UI pueda mostrar información contextual\n      status: data.status,\n      advisorStatus: data.advisor_status,\n      companyStatus: data.company_status,\n      globalStatus: data.global_status\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] Error al obtener el estado de aprobación para ${id}:`, error);\n\n    // En caso de error, devolvemos valor indefinido para que la UI maneje el caso correctamente\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id, entityFilter) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId, userId, text, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount, interestRate, termMonths) => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n\n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n\n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  const monthlyPayment = loanAmount * (numerator / denominator);\n\n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (id, status, statusField, comment, user_id, entityFilter) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Fetch the application\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).single();\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : application[statusField] || application.status;\n\n    // Prepare the update data - ONLY update the specific field requested\n    const updateData = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // Additional specific logic for approval status changes\n    if (statusField === 'advisor_status') {\n      // Update the approved_by_advisor flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_advisor = true;\n        updateData.approval_date_advisor = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_advisor = false;\n          updateData.approval_date_advisor = null;\n        }\n      }\n\n      // CRITICAL: Do NOT update the main status field when making advisor-specific changes\n      // Remove any code that would update 'status' here\n    } else if (statusField === 'company_status') {\n      // Update the approved_by_company flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_company = true;\n        updateData.approval_date_company = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_company = false;\n          updateData.approval_date_company = null;\n        }\n      }\n\n      // CRITICAL: Do NOT update the main status field when making company-specific changes\n      // Remove any code that would update 'status' here\n    } else if (statusField === 'status') {\n      // When explicitly updating the main status field, we allow it\n      updateData.status = status;\n    }\n\n    // Special logic for when both parties have approved\n    if (status === APPLICATION_STATUS.APPROVED && (statusField === 'advisor_status' && application.approved_by_company === true || statusField === 'company_status' && application.approved_by_advisor === true)) {\n      // Both parties have approved, update global_status to POR_DISPERSAR\n      console.log('Both parties have approved, updating global_status to POR_DISPERSAR');\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n\n    // Special logic for when any party rejects the application\n    if (status === APPLICATION_STATUS.REJECTED && (statusField === 'advisor_status' || statusField === 'company_status')) {\n      // When any party rejects, update all statuses to REJECTED\n      console.log('Application rejected, updating all statuses to REJECTED');\n      updateData.global_status = APPLICATION_STATUS.REJECTED;\n      updateData.status = APPLICATION_STATUS.REJECTED;\n      updateData.advisor_status = APPLICATION_STATUS.REJECTED;\n      updateData.company_status = APPLICATION_STATUS.REJECTED;\n    }\n\n    // When using the global_status field, also update the main status to match\n    if (statusField === 'global_status') {\n      updateData.status = status;\n    }\n    console.log(`Updating application ${id} ${statusField} to ${status}`, updateData);\n\n    // Update the application\n    const {\n      error: updateError\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert([historyEntry]);\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n    return {\n      success: true,\n      application: {\n        ...application,\n        [statusField]: status,\n        // Include these updated fields in the response so the UI can reflect them\n        ...(statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED ? {\n          approved_by_advisor: true,\n          approval_date_advisor: updateData.approval_date_advisor\n        } : {}),\n        ...(statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED ? {\n          approved_by_company: true,\n          approval_date_company: updateData.approval_date_company\n        } : {})\n      }\n    };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n};\n\n// Marcar solicitud como dispersada (solo asesores)\nexport const markAsDispersed = async (id, comment, advisor_id, entityFilter) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id)) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  try {\n    console.log(`Marcando solicitud ${id} como dispersada por asesor ${advisor_id}...`);\n\n    // Primero obtenemos la aplicación para verificar su estado actual\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).eq('assigned_to', advisor_id).single();\n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para marcarla como dispersada');\n    }\n\n    // Verificar que la solicitud está en estado POR_DISPERSAR\n    if (application.status !== APPLICATION_STATUS.POR_DISPERSAR) {\n      throw new Error('Solo las solicitudes que están Por Dispersar pueden ser marcadas como dispersadas');\n    }\n\n    // Preparar los campos a actualizar - todos los estados pasan a COMPLETED\n    const updateData = {\n      status: APPLICATION_STATUS.COMPLETED,\n      global_status: APPLICATION_STATUS.COMPLETED,\n      advisor_status: APPLICATION_STATUS.COMPLETED,\n      company_status: APPLICATION_STATUS.COMPLETED,\n      dispersal_date: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n\n    // Actualizar la aplicación\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id).eq('assigned_to', advisor_id).select('*');\n    if (error) {\n      console.error(`Error marcando solicitud ${id} como dispersada:`, error);\n      throw new Error(`Error al marcar solicitud como dispersada: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para marcarla como dispersada');\n    }\n    console.log(`Solicitud ${id} marcada exitosamente como dispersada por asesor ${advisor_id}`);\n\n    // Añadir al historial\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      previous_status: APPLICATION_STATUS.POR_DISPERSAR,\n      new_status: APPLICATION_STATUS.COMPLETED,\n      status_field: 'global_status',\n      changed_by: advisor_id,\n      comments: comment || 'Solicitud marcada como dispersada',\n      changed_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de dispersión:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error marcando solicitud ${id} como dispersada:`, error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","supabase","executeQuery","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","getApplications","filters","entityFilter","console","log","query","from","APPLICATIONS","select","advisor_id","eq","company_id","status","application_type","dateFrom","gte","dateTo","lte","amountMin","amountMax","searchQuery","searchTerm","toLowerCase","or","order","ascending","data","error","Array","isArray","length","types","Set","map","app","matchingApps","filter","mappedStatus","mapStatusFromDB","advisorStatus","advisor_status","companyStatus","company_status","globalStatus","global_status","id","client_id","source_id","assigned_to","requested_amount","parseFloat","amount","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","undefined","interest_rate","monthly_payment","financing_type","product_url","product_title","product_image","dbStatus","NEW","normalizedStatus","trim","directMapping","Object","values","find","statusMap","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","getApplicationById","Error","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","key","value","updateApplicationStatus","comment","user_id","currentStateData","fetchError","message","currentStatus","updateData","status_previous","dispersal_date","Date","toISOString","updateQuery","update","updatedApp","updateError","historyComment","historyError","insert","application_id","created_by","historyErr","approveByAdvisor","single","previous_status","new_status","status_field","changed_by","comments","changed_at","approveByCompany","company_admin_id","cancelCompanyApproval","getApprovalStatus","warn","isFullyApproved","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments","calculateMonthlyPayment","loanAmount","interestRate","termMonths","monthlyInterestRate","numerator","Math","pow","denominator","monthlyPayment","round","updateApplicationStatusField","statusField","includes","previousStatus","historyEntry","success","markAsDispersed"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase, getServiceClient } from '../services/supabaseService';\nimport { executeQuery, escapeSqlString } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  application_type: string;\n  product_type?: string;  // Tipo de producto (préstamo personal, auto, etc.)\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  \n  // Añadir campos de estado específicos para cada rol \n  advisor_status?: ApplicationStatus;\n  company_status?: ApplicationStatus;\n  global_status?: ApplicationStatus;\n  \n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  client_phone?: string;\n  client_address?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  dni?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n  \n  // Campo de tipo de financiamiento\n  financing_type?: string;\n  product_url?: string;\n  product_title?: string;\n  product_image?: string;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  try {\n    console.log(\"getApplications called with filters:\", filters);\n    \n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*');\n    \n    // Aplicar filtro de entidad\n    if (entityFilter?.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    \n    if (entityFilter?.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n    \n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n      \n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        console.log(`Applying application_type filter: ${filters.application_type}`);\n        query = query.eq('application_type', filters.application_type);\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n      \n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      \n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n      \n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      \n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n      \n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n    \n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', { ascending: false });\n    \n    // Ejecutar la consulta\n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    \n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n    \n    console.log(`Retrieved ${data.length} applications from database`);\n    \n    // Log the types of applications we retrieved\n    const types = new Set(data.map(app => app.application_type));\n    console.log('DB application types:', Array.from(types));\n    \n    // Double-check if the filter was applied correctly\n    if (filters?.application_type) {\n      const matchingApps = data.filter(app => app.application_type === filters.application_type);\n      console.log(`After DB query: ${matchingApps.length} of ${data.length} apps match type '${filters.application_type}'`);\n    }\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => {\n      // Obtener el estado mapeado\n      const mappedStatus = mapStatusFromDB(app.status);\n      \n      // Asegurar que los estados específicos por rol estén inicializados\n      // Si no existen, usar el estado principal\n      const advisorStatus = app.advisor_status ? mapStatusFromDB(app.advisor_status) : mappedStatus;\n      const companyStatus = app.company_status ? mapStatusFromDB(app.company_status) : mappedStatus;\n      const globalStatus = app.global_status ? mapStatusFromDB(app.global_status) : mappedStatus;\n      \n      return {\n        id: app.id,\n        client_id: app.source_id || \"\",\n        company_id: app.company_id || \"\",\n        assigned_to: app.assigned_to || \"\",\n        application_type: app.application_type || \"\",\n        requested_amount: parseFloat(app.amount) || 0,\n        status: mappedStatus,\n        \n        // Añadir los estados específicos para cada rol\n        advisor_status: advisorStatus,\n        company_status: companyStatus,\n        global_status: globalStatus,\n        \n        created_at: app.created_at,\n        updated_at: app.updated_at,\n        client_name: app.client_name,\n        client_email: app.client_email,\n        company_name: app.company_name,\n        advisor_name: \"\", // Este campo no está en la BD\n        approved_by_advisor: app.approved_by_advisor || false,\n        approved_by_company: app.approved_by_company || false,\n        approval_date_advisor: app.approval_date_advisor,\n        approval_date_company: app.approval_date_company,\n        \n        // Mapeo directo de campos adicionales de la BD\n        client_phone: app.client_phone,\n        client_address: app.client_address,\n        dni: app.dni,\n        amount: parseFloat(app.amount) || 0,\n        term: app.term ? parseInt(app.term) : undefined,\n        interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n        monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n        \n        // Campos para tipo de financiamiento y productos\n        financing_type: app.financing_type || null,\n        product_url: app.product_url || null,\n        product_title: app.product_title || null,\n        product_image: app.product_image || null,\n      };\n    }) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string): ApplicationStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n  \n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === normalizedStatus\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return (statusMap[normalizedStatus] || APPLICATION_STATUS.NEW) as ApplicationStatus;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, { entityFilter });\n  \n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('status, assigned_to, company_id')\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: currentStateData, error: fetchError } = await query;\n    \n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    \n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, { entityFilter });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n    \n    // 2. Update the application using Supabase client\n    const updateData: Partial<Application> = {\n      status: status,\n      status_previous: currentStatus\n    };\n    \n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    \n    let updateQuery = supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: updatedApp, error: updateError } = await updateQuery.select();\n    \n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Add to history\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    try {\n      const { error: historyError } = await supabase\n        .from(APPLICATION_HISTORY_TABLE)\n        .insert({\n          application_id: id,\n          status: status,\n          comment: historyComment,\n          created_by: user_id\n        });\n      \n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    \n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n    \n    // Primero obtenemos la aplicación para verificar el estado de la aprobación de la empresa\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .single();\n    \n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    \n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Preparar los campos a actualizar\n    const updateData: Record<string, any> = {\n      approved_by_advisor: true,\n      approval_date_advisor: new Date().toISOString(),\n      advisor_status: APPLICATION_STATUS.APPROVED, // Siempre actualizar el estado específico del asesor\n      updated_at: new Date().toISOString()\n    };\n    \n    // Solo actualizar el estado global si la empresa ya ha aprobado\n    if (application.approved_by_company === true) {\n      // Cuando ambos aprueban, automáticamente pasa a POR_DISPERSAR\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n    \n    // Actualizar la aplicación\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        previous_status: application.advisor_status || application.status,\n        new_status: APPLICATION_STATUS.APPROVED,\n        status_field: 'advisor_status',\n        changed_by: advisor_id,\n        comments: comment || 'Solicitud aprobada por asesor',\n        changed_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Primero obtenemos la aplicación para verificar el estado de la aprobación del asesor\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .single();\n    \n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    \n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Preparar los campos a actualizar\n    const updateData: Record<string, any> = {\n      approved_by_company: true,\n      approval_date_company: new Date().toISOString(),\n      company_status: APPLICATION_STATUS.APPROVED, // Siempre actualizar el estado específico de la empresa\n      updated_at: new Date().toISOString()\n    };\n    \n    // Solo actualizar el estado global si el asesor ya ha aprobado\n    if (application.approved_by_advisor === true) {\n      // Cuando ambos aprueban, automáticamente pasa a POR_DISPERSAR\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n    \n    // Actualizar la aplicación\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        previous_status: application.company_status || application.status,\n        new_status: APPLICATION_STATUS.APPROVED,\n        status_field: 'company_status',\n        changed_by: company_admin_id,\n        comments: comment || 'Solicitud aprobada por empresa',\n        changed_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Primero obtenemos la aplicación para verificar su estado actual\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .single();\n    \n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    \n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n\n    // Preparar los campos a actualizar\n    const updateData: Record<string, any> = {\n      approved_by_company: false,\n      approval_date_company: null,\n      company_status: APPLICATION_STATUS.IN_REVIEW, // Solo cambiamos el estado de la empresa\n      updated_at: new Date().toISOString()\n    };\n    \n    // Solo actualizar el estado global si estaba basado en la aprobación completa\n    if (application.status === APPLICATION_STATUS.APPROVED && \n        application.advisor_status === APPLICATION_STATUS.APPROVED && \n        application.company_status === APPLICATION_STATUS.APPROVED) {\n      // Revertir al estado de revisión ya que una parte retiró su aprobación\n      updateData.status = APPLICATION_STATUS.IN_REVIEW;\n      updateData.global_status = APPLICATION_STATUS.IN_REVIEW;\n    }\n    \n    // Actualizar la aplicación\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        previous_status: application.company_status || application.status,\n        new_status: APPLICATION_STATUS.IN_REVIEW,\n        status_field: 'company_status',\n        changed_by: company_admin_id,\n        comments: comment || 'Aprobación de empresa cancelada',\n        changed_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  try {\n    // Usar Supabase client para obtener los datos\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select(`\n        approved_by_advisor, \n        approved_by_company, \n        approval_date_advisor, \n        approval_date_company,\n        status,\n        advisor_status,\n        company_status,\n        global_status\n      `)\n      .eq('id', id);\n    \n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data, error } = await query.single();\n    \n    if (error) {\n      console.error(`Error obteniendo estado de aprobación para ${id}:`, error);\n      \n      // En caso de error, devolvemos valor indefinido para que la UI maneje el caso correctamente\n      return undefined;\n    }\n    \n    if (!data) {\n      console.warn(`Solicitud ${id} no encontrada para obtener estado de aprobación`);\n      return undefined;\n    }\n    \n    // Verificar si la solicitud está totalmente aprobada (ambas partes)\n    const isFullyApproved = data.approved_by_advisor === true && data.approved_by_company === true;\n    \n    return {\n      approvedByAdvisor: data.approved_by_advisor === true,\n      approvedByCompany: data.approved_by_company === true,\n      approvalDateAdvisor: data.approval_date_advisor,\n      approvalDateCompany: data.approval_date_company,\n      isFullyApproved: isFullyApproved,\n      // Incluir estados para que la UI pueda mostrar información contextual\n      status: data.status,\n      advisorStatus: data.advisor_status,\n      companyStatus: data.company_status,\n      globalStatus: data.global_status\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] Error al obtener el estado de aprobación para ${id}:`, error);\n    \n    // En caso de error, devolvemos valor indefinido para que la UI maneje el caso correctamente\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as { \n      id: string;\n      application_id: string;\n      user_id: string;\n      text: string;\n      created_at: string;\n    };\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\nexport interface ApplicationWithClient {\n  // ... existing code ...\n}\n\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount: number, interestRate: number, termMonths: number): number => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n  \n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n  \n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  \n  const monthlyPayment = loanAmount * (numerator / denominator);\n  \n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (\n  id: string, \n  status: Application['status'],\n  statusField: 'advisor_status' | 'company_status' | 'global_status' | 'status',\n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Fetch the application\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : (application[statusField] || application.status);\n\n    // Prepare the update data - ONLY update the specific field requested\n    const updateData: Record<string, any> = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // Additional specific logic for approval status changes\n    if (statusField === 'advisor_status') {\n      // Update the approved_by_advisor flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_advisor = true;\n        updateData.approval_date_advisor = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_advisor = false;\n          updateData.approval_date_advisor = null;\n        }\n      }\n      \n      // CRITICAL: Do NOT update the main status field when making advisor-specific changes\n      // Remove any code that would update 'status' here\n    } \n    else if (statusField === 'company_status') {\n      // Update the approved_by_company flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_company = true;\n        updateData.approval_date_company = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_company = false;\n          updateData.approval_date_company = null;\n        }\n      }\n      \n      // CRITICAL: Do NOT update the main status field when making company-specific changes\n      // Remove any code that would update 'status' here\n    }\n    else if (statusField === 'status') {\n      // When explicitly updating the main status field, we allow it\n      updateData.status = status;\n    }\n    \n    // Special logic for when both parties have approved\n    if (\n      status === APPLICATION_STATUS.APPROVED &&\n      ((statusField === 'advisor_status' && application.approved_by_company === true) ||\n       (statusField === 'company_status' && application.approved_by_advisor === true))\n    ) {\n      // Both parties have approved, update global_status to POR_DISPERSAR\n      console.log('Both parties have approved, updating global_status to POR_DISPERSAR');\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.advisor_status = APPLICATION_STATUS.POR_DISPERSAR;\n      updateData.company_status = APPLICATION_STATUS.POR_DISPERSAR;\n    }\n    \n    // Special logic for when any party rejects the application\n    if (status === APPLICATION_STATUS.REJECTED && \n        (statusField === 'advisor_status' || statusField === 'company_status')) {\n      // When any party rejects, update all statuses to REJECTED\n      console.log('Application rejected, updating all statuses to REJECTED');\n      updateData.global_status = APPLICATION_STATUS.REJECTED;\n      updateData.status = APPLICATION_STATUS.REJECTED;\n      updateData.advisor_status = APPLICATION_STATUS.REJECTED;\n      updateData.company_status = APPLICATION_STATUS.REJECTED;\n    }\n    \n    // When using the global_status field, also update the main status to match\n    if (statusField === 'global_status') {\n      updateData.status = status;\n    }\n\n    console.log(`Updating application ${id} ${statusField} to ${status}`, updateData);\n\n    // Update the application\n    const { error: updateError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert([historyEntry]);\n\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n\n    return { \n      success: true, \n      application: { \n        ...application, \n        [statusField]: status,\n        // Include these updated fields in the response so the UI can reflect them\n        ...(statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED \n            ? { approved_by_advisor: true, approval_date_advisor: updateData.approval_date_advisor } \n            : {}),\n        ...(statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED \n            ? { approved_by_company: true, approval_date_company: updateData.approval_date_company } \n            : {})\n      } \n    };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n};\n\n// Marcar solicitud como dispersada (solo asesores)\nexport const markAsDispersed = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  try {\n    console.log(`Marcando solicitud ${id} como dispersada por asesor ${advisor_id}...`);\n    \n    // Primero obtenemos la aplicación para verificar su estado actual\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .single();\n    \n    if (fetchError) {\n      console.error(`Error obteniendo solicitud ${id}:`, fetchError);\n      throw new Error(`Error al obtener solicitud: ${fetchError.message}`);\n    }\n    \n    if (!application) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para marcarla como dispersada');\n    }\n    \n    // Verificar que la solicitud está en estado POR_DISPERSAR\n    if (application.status !== APPLICATION_STATUS.POR_DISPERSAR) {\n      throw new Error('Solo las solicitudes que están Por Dispersar pueden ser marcadas como dispersadas');\n    }\n    \n    // Preparar los campos a actualizar - todos los estados pasan a COMPLETED\n    const updateData: Record<string, any> = {\n      status: APPLICATION_STATUS.COMPLETED,\n      global_status: APPLICATION_STATUS.COMPLETED,\n      advisor_status: APPLICATION_STATUS.COMPLETED,\n      company_status: APPLICATION_STATUS.COMPLETED, \n      dispersal_date: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n    \n    // Actualizar la aplicación\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error marcando solicitud ${id} como dispersada:`, error);\n      throw new Error(`Error al marcar solicitud como dispersada: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para marcarla como dispersada');\n    }\n    \n    console.log(`Solicitud ${id} marcada exitosamente como dispersada por asesor ${advisor_id}`);\n    \n    // Añadir al historial\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        previous_status: APPLICATION_STATUS.POR_DISPERSAR,\n        new_status: APPLICATION_STATUS.COMPLETED,\n        status_field: 'global_status',\n        changed_by: advisor_id,\n        comments: comment || 'Solicitud marcada como dispersada',\n        changed_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de dispersión:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error marcando solicitud ${id} como dispersada:`, error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}