{"ast":null,"code":"/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */export const executeQuery=async query=>{try{const url='http://localhost:3100/query';const response=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({query})});if(!response.ok){const errorText=await response.text();// Try to parse error as JSON if possible\nlet errorDetail;try{errorDetail=JSON.parse(errorText);}catch{errorDetail=errorText;}// Check for relation/table not existing in error message\nconst errorDetailStr=JSON.stringify(errorDetail);if(errorDetailStr.includes('relation')&&errorDetailStr.includes('does not exist')){console.warn('Tabla no encontrada en la base de datos:',errorDetailStr);return[];// Retornar array vacío en lugar de lanzar error\n}throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${errorDetailStr}`);}const result=await response.json();return result.data||[];}catch(error){// Check if error is about missing relation/table\nconst errorMessage=error instanceof Error?error.message:String(error);if(errorMessage.includes('relation')&&errorMessage.includes('does not exist')){console.warn('Error ejecutando consulta - tabla no existe:',errorMessage);return[];// Retornar array vacío en lugar de lanzar error\n}console.error('Error ejecutando consulta:',error);throw error;}};/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */export const escapeSqlString=value=>{if(!value)return'';// Reemplazar comillas simples por dos comillas simples (estándar SQL)\nreturn value.replace(/'/g,\"''\");};/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */export const formatDateForSql=date=>{return date.toISOString();};/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */export const objectToSqlWhere=conditions=>{const clauses=[];for(const[key,value]of Object.entries(conditions)){if(value===undefined||value===null)continue;if(typeof value==='string'){clauses.push(`${key} = '${escapeSqlString(value)}'`);}else if(typeof value==='number'||typeof value==='boolean'){clauses.push(`${key} = ${value}`);}else if(value instanceof Date){clauses.push(`${key} = '${formatDateForSql(value)}'`);}else if(Array.isArray(value)){const formattedValues=value.map(v=>typeof v==='string'?`'${escapeSqlString(v)}'`:v);clauses.push(`${key} IN (${formattedValues.join(',')})`);}}return clauses.length>0?clauses.join(' AND '):'1=1';};","map":{"version":3,"names":["executeQuery","query","url","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","errorDetail","parse","errorDetailStr","includes","console","warn","Error","statusText","result","json","data","error","errorMessage","message","String","escapeSqlString","value","replace","formatDateForSql","date","toISOString","objectToSqlWhere","conditions","clauses","key","Object","entries","undefined","push","Date","Array","isArray","formattedValues","map","v","join","length"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/databaseUtils.ts"],"sourcesContent":["/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */\nexport const executeQuery = async (query: string): Promise<any[]> => {\n  try {\n    const url = 'http://localhost:3100/query';\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Try to parse error as JSON if possible\n      let errorDetail;\n      try {\n        errorDetail = JSON.parse(errorText);\n      } catch {\n        errorDetail = errorText;\n      }\n      \n      // Check for relation/table not existing in error message\n      const errorDetailStr = JSON.stringify(errorDetail);\n      if (errorDetailStr.includes('relation') && errorDetailStr.includes('does not exist')) {\n        console.warn('Tabla no encontrada en la base de datos:', errorDetailStr);\n        return []; // Retornar array vacío en lugar de lanzar error\n      }\n      \n      throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${errorDetailStr}`);\n    }\n\n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    // Check if error is about missing relation/table\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    if (errorMessage.includes('relation') && errorMessage.includes('does not exist')) {\n      console.warn('Error ejecutando consulta - tabla no existe:', errorMessage);\n      return []; // Retornar array vacío en lugar de lanzar error\n    }\n    \n    console.error('Error ejecutando consulta:', error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = (value: string): string => {\n  if (!value) return '';\n  \n  // Reemplazar comillas simples por dos comillas simples (estándar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = (date: Date): string => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = (conditions: Record<string, any>): string => {\n  const clauses = [];\n  \n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    \n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => \n        typeof v === 'string' ? `'${escapeSqlString(v)}'` : v\n      );\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  \n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}