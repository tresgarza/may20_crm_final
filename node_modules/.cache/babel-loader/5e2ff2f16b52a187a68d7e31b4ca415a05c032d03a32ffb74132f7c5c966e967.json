{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase } from '../services/supabaseService';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\n\n// Define application interface\n\n// Get all applications with filters\nexport const getApplications = async (filters, entityFilter) => {\n  try {\n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase.from(TABLES.APPLICATIONS).select('*');\n\n    // Aplicar filtro de entidad\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n\n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n\n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        query = query.eq('application_type', filters.application_type);\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n\n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n\n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', {\n      ascending: false\n    });\n\n    // Ejecutar la consulta\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n\n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map(app => {\n      // Obtener el estado mapeado\n      const mappedStatus = mapStatusFromDB(app.status);\n\n      // Asegurar que los estados específicos por rol estén inicializados\n      // Si no existen, usar el estado principal\n      const advisorStatus = app.advisor_status ? mapStatusFromDB(app.advisor_status) : mappedStatus;\n      const companyStatus = app.company_status ? mapStatusFromDB(app.company_status) : mappedStatus;\n      const globalStatus = app.global_status ? mapStatusFromDB(app.global_status) : mappedStatus;\n      return {\n        id: app.id,\n        client_id: app.source_id || \"\",\n        company_id: app.company_id || \"\",\n        assigned_to: app.assigned_to || \"\",\n        application_type: app.application_type || \"\",\n        requested_amount: parseFloat(app.amount) || 0,\n        status: mappedStatus,\n        // Añadir los estados específicos para cada rol\n        advisor_status: advisorStatus,\n        company_status: companyStatus,\n        global_status: globalStatus,\n        created_at: app.created_at,\n        updated_at: app.updated_at,\n        client_name: app.client_name,\n        client_email: app.client_email,\n        company_name: app.company_name,\n        advisor_name: \"\",\n        // Este campo no está en la BD\n        approved_by_advisor: app.approved_by_advisor || false,\n        approved_by_company: app.approved_by_company || false,\n        approval_date_advisor: app.approval_date_advisor,\n        approval_date_company: app.approval_date_company,\n        // Mapeo directo de campos adicionales de la BD\n        client_phone: app.client_phone,\n        client_address: app.client_address,\n        dni: app.dni,\n        amount: parseFloat(app.amount) || 0,\n        term: app.term ? parseInt(app.term) : undefined,\n        interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n        monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined\n      };\n    });\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = dbStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n\n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => status.toLowerCase() === normalizedStatus);\n  if (directMapping) {\n    return directMapping;\n  }\n\n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return statusMap[normalizedStatus] || APPLICATION_STATUS.NEW;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async application => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ');\n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id, updates, entityFilter) => {\n  const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`).join(', ');\n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  query += ' RETURNING *';\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (id, status, comment, user_id, entityFilter) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, {\n    entityFilter\n  });\n\n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase.from(TABLES.APPLICATIONS).select('status, assigned_to, company_id').eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: currentStateData,\n      error: fetchError\n    } = await query;\n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, {\n        entityFilter\n      });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n\n    // 2. Update the application using Supabase client\n    const updateData = {\n      status: status,\n      status_previous: currentStatus\n    };\n\n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    let updateQuery = supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: updatedApp,\n      error: updateError\n    } = await updateQuery.select();\n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n\n    // 3. Add to history\n    const historyComment = currentStatus !== status ? `${comment} (Cambio de estado: ${currentStatus} → ${status})` : comment;\n    try {\n      const {\n        error: historyError\n      } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n        application_id: id,\n        status: status,\n        comment: historyComment,\n        created_by: user_id\n      });\n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (id, comment, advisor_id, entityFilter) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id)) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_advisor: true,\n      approval_date_advisor: new Date().toISOString(),\n      status: 'approved' // Update the status to 'approved' when advisor approves\n    }).eq('id', id).eq('assigned_to', advisor_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: 'approved',\n      // Cambiado de status_previous/status_new a solo status\n      comment: comment,\n      created_by: advisor_id,\n      created_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'por_dispersar') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'por_dispersar'\");\n\n      // Si ambos han aprobado, actualizar el estado a por_dispersar\n      return await updateApplicationStatus(id, 'por_dispersar', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', advisor_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_company: true,\n      approval_date_company: new Date().toISOString()\n    }).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: 'approved_by_company',\n      // Ya está usando el formato correcto\n      comment: comment,\n      created_by: company_admin_id\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n\n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(id, 'approved', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', company_admin_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_company: false,\n      approval_date_company: null,\n      status: APPLICATION_STATUS.IN_REVIEW\n    }).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: APPLICATION_STATUS.IN_REVIEW,\n      comment: comment,\n      created_by: company_admin_id\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (id, entityFilter) => {\n  // Store last successful result for this application ID\n  const cachedResultKey = `approval_status_${id}`;\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      const appData = data[0];\n\n      // Cache successful result in session storage\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(appData));\n      } catch (e) {\n        // Ignore storage errors\n      }\n      return {\n        approvedByAdvisor: appData.approved_by_advisor,\n        approvedByCompany: appData.approved_by_company,\n        approvalDateAdvisor: appData.approval_date_advisor,\n        approvalDateCompany: appData.approval_date_company\n      };\n    }\n\n    // Check for cached data if no results found\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id}`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    console.warn(`Solicitud ${id} no encontrada, retornando valores por defecto`);\n    return {\n      approvedByAdvisor: undefined,\n      approvedByCompany: undefined,\n      approvalDateAdvisor: undefined,\n      approvalDateCompany: undefined\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] fallo – conservo estado local para solicitud ${id}:`, error);\n\n    // Try to return cached data if available\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id} after error`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n\n    // Return undefined instead of false values\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id, entityFilter) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId, userId, text, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount, interestRate, termMonths) => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n\n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n\n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  const monthlyPayment = loanAmount * (numerator / denominator);\n\n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (id, status, statusField, comment, user_id, entityFilter) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Fetch the application\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).single();\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : application[statusField] || application.status;\n\n    // Prepare the update data - ONLY update the specific field requested\n    const updateData = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // Additional specific logic for approval status changes\n    if (statusField === 'advisor_status') {\n      // Update the approved_by_advisor flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_advisor = true;\n        updateData.approval_date_advisor = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_advisor = false;\n          updateData.approval_date_advisor = null;\n        }\n      }\n\n      // CRITICAL: Do NOT update the main status field when making advisor-specific changes\n      // Remove any code that would update 'status' here\n    } else if (statusField === 'company_status') {\n      // Update the approved_by_company flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_company = true;\n        updateData.approval_date_company = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_company = false;\n          updateData.approval_date_company = null;\n        }\n      }\n\n      // CRITICAL: Do NOT update the main status field when making company-specific changes\n      // Remove any code that would update 'status' here\n    } else if (statusField === 'status') {\n      // When explicitly updating the main status field, we allow it\n      updateData.status = status;\n    }\n\n    // Special logic for when both parties have approved\n    if (status === APPLICATION_STATUS.APPROVED && (statusField === 'advisor_status' && application.approved_by_company === true || statusField === 'company_status' && application.approved_by_advisor === true)) {\n      // Both parties have approved, update global_status to POR_DISPERSAR\n      console.log('Both parties have approved, updating global_status to POR_DISPERSAR');\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n\n      // IMPORTANT: Do NOT automatically update the main status field\n      // This should only happen if explicitly using 'status' or 'global_status' statusField\n    }\n\n    // When using the global_status field, also update the main status to match\n    if (statusField === 'global_status') {\n      updateData.status = status;\n    }\n    console.log(`Updating application ${id} ${statusField} to ${status}`, updateData);\n\n    // Update the application\n    const {\n      error: updateError\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert([historyEntry]);\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n    return {\n      success: true,\n      application: {\n        ...application,\n        [statusField]: status,\n        // Include these updated fields in the response so the UI can reflect them\n        ...(statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED ? {\n          approved_by_advisor: true,\n          approval_date_advisor: updateData.approval_date_advisor\n        } : {}),\n        ...(statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED ? {\n          approved_by_company: true,\n          approval_date_company: updateData.approval_date_company\n        } : {})\n      }\n    };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","supabase","executeQuery","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","getApplications","filters","entityFilter","query","from","APPLICATIONS","select","advisor_id","eq","company_id","status","application_type","dateFrom","gte","dateTo","lte","amountMin","amountMax","searchQuery","searchTerm","toLowerCase","or","order","ascending","data","error","console","Array","isArray","length","map","app","mappedStatus","mapStatusFromDB","advisorStatus","advisor_status","companyStatus","company_status","globalStatus","global_status","id","client_id","source_id","assigned_to","requested_amount","parseFloat","amount","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","undefined","interest_rate","monthly_payment","dbStatus","log","NEW","normalizedStatus","trim","directMapping","Object","values","find","statusMap","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","getApplicationById","Error","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","key","value","updateApplicationStatus","comment","user_id","currentStateData","fetchError","message","currentStatus","updateData","status_previous","dispersal_date","Date","toISOString","updateQuery","update","updatedApp","updateError","historyComment","historyError","insert","application_id","created_by","historyErr","approveByAdvisor","approveByCompany","company_admin_id","cancelCompanyApproval","getApprovalStatus","cachedResultKey","appData","sessionStorage","setItem","JSON","stringify","e","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","cachedData","getItem","parsedData","parse","warn","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments","calculateMonthlyPayment","loanAmount","interestRate","termMonths","monthlyInterestRate","numerator","Math","pow","denominator","monthlyPayment","round","updateApplicationStatusField","statusField","includes","single","previousStatus","historyEntry","previous_status","new_status","status_field","changed_by","comments","changed_at","success"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase, getServiceClient } from '../services/supabaseService';\nimport { executeQuery, escapeSqlString } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  application_type: string;\n  product_type?: string;  // Tipo de producto (préstamo personal, auto, etc.)\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  \n  // Añadir campos de estado específicos para cada rol \n  advisor_status?: ApplicationStatus;\n  company_status?: ApplicationStatus;\n  global_status?: ApplicationStatus;\n  \n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  client_phone?: string;\n  client_address?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  dni?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  try {\n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*');\n    \n    // Aplicar filtro de entidad\n    if (entityFilter?.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    \n    if (entityFilter?.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n    \n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n      \n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        query = query.eq('application_type', filters.application_type);\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n      \n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      \n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n      \n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      \n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n      \n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n    \n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', { ascending: false });\n    \n    // Ejecutar la consulta\n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    \n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => {\n      // Obtener el estado mapeado\n      const mappedStatus = mapStatusFromDB(app.status);\n      \n      // Asegurar que los estados específicos por rol estén inicializados\n      // Si no existen, usar el estado principal\n      const advisorStatus = app.advisor_status ? mapStatusFromDB(app.advisor_status) : mappedStatus;\n      const companyStatus = app.company_status ? mapStatusFromDB(app.company_status) : mappedStatus;\n      const globalStatus = app.global_status ? mapStatusFromDB(app.global_status) : mappedStatus;\n      \n      return {\n        id: app.id,\n        client_id: app.source_id || \"\",\n        company_id: app.company_id || \"\",\n        assigned_to: app.assigned_to || \"\",\n        application_type: app.application_type || \"\",\n        requested_amount: parseFloat(app.amount) || 0,\n        status: mappedStatus,\n        \n        // Añadir los estados específicos para cada rol\n        advisor_status: advisorStatus,\n        company_status: companyStatus,\n        global_status: globalStatus,\n        \n        created_at: app.created_at,\n        updated_at: app.updated_at,\n        client_name: app.client_name,\n        client_email: app.client_email,\n        company_name: app.company_name,\n        advisor_name: \"\", // Este campo no está en la BD\n        approved_by_advisor: app.approved_by_advisor || false,\n        approved_by_company: app.approved_by_company || false,\n        approval_date_advisor: app.approval_date_advisor,\n        approval_date_company: app.approval_date_company,\n        \n        // Mapeo directo de campos adicionales de la BD\n        client_phone: app.client_phone,\n        client_address: app.client_address,\n        dni: app.dni,\n        amount: parseFloat(app.amount) || 0,\n        term: app.term ? parseInt(app.term) : undefined,\n        interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n        monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n      };\n    }) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string): ApplicationStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n  \n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === normalizedStatus\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return (statusMap[normalizedStatus] || APPLICATION_STATUS.NEW) as ApplicationStatus;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, { entityFilter });\n  \n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('status, assigned_to, company_id')\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: currentStateData, error: fetchError } = await query;\n    \n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    \n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, { entityFilter });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n    \n    // 2. Update the application using Supabase client\n    const updateData: Partial<Application> = {\n      status: status,\n      status_previous: currentStatus\n    };\n    \n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    \n    let updateQuery = supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: updatedApp, error: updateError } = await updateQuery.select();\n    \n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Add to history\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    try {\n      const { error: historyError } = await supabase\n        .from(APPLICATION_HISTORY_TABLE)\n        .insert({\n          application_id: id,\n          status: status,\n          comment: historyComment,\n          created_by: user_id\n        });\n      \n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    \n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n    \n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_advisor: true,\n        approval_date_advisor: new Date().toISOString(),\n        status: 'approved' // Update the status to 'approved' when advisor approves\n      })\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: 'approved', // Cambiado de status_previous/status_new a solo status\n        comment: comment,\n        created_by: advisor_id,\n        created_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'por_dispersar') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'por_dispersar'\");\n      \n      // Si ambos han aprobado, actualizar el estado a por_dispersar\n      return await updateApplicationStatus(\n        id, \n        'por_dispersar', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        advisor_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_company: true,\n        approval_date_company: new Date().toISOString()\n      })\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: 'approved_by_company', // Ya está usando el formato correcto\n        comment: comment,\n        created_by: company_admin_id\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        company_admin_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_company: false,\n        approval_date_company: null,\n        status: APPLICATION_STATUS.IN_REVIEW\n      })\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: APPLICATION_STATUS.IN_REVIEW,\n        comment: comment,\n        created_by: company_admin_id\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Store last successful result for this application ID\n  const cachedResultKey = `approval_status_${id}`;\n  \n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      const appData = data[0] as {\n        approved_by_advisor: boolean,\n        approved_by_company: boolean,\n        approval_date_advisor: string,\n        approval_date_company: string\n      };\n      \n      // Cache successful result in session storage\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(appData));\n      } catch (e) {\n        // Ignore storage errors\n      }\n      \n      return {\n        approvedByAdvisor: appData.approved_by_advisor,\n        approvedByCompany: appData.approved_by_company,\n        approvalDateAdvisor: appData.approval_date_advisor,\n        approvalDateCompany: appData.approval_date_company\n      };\n    }\n    \n    // Check for cached data if no results found\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id}`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    \n    console.warn(`Solicitud ${id} no encontrada, retornando valores por defecto`);\n    return {\n      approvedByAdvisor: undefined,\n      approvedByCompany: undefined,\n      approvalDateAdvisor: undefined,\n      approvalDateCompany: undefined\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] fallo – conservo estado local para solicitud ${id}:`, error);\n    \n    // Try to return cached data if available\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id} after error`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    \n    // Return undefined instead of false values\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as { \n      id: string;\n      application_id: string;\n      user_id: string;\n      text: string;\n      created_at: string;\n    };\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\nexport interface ApplicationWithClient {\n  // ... existing code ...\n}\n\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount: number, interestRate: number, termMonths: number): number => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n  \n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n  \n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  \n  const monthlyPayment = loanAmount * (numerator / denominator);\n  \n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (\n  id: string, \n  status: Application['status'],\n  statusField: 'advisor_status' | 'company_status' | 'global_status' | 'status',\n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Fetch the application\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : (application[statusField] || application.status);\n\n    // Prepare the update data - ONLY update the specific field requested\n    const updateData: Record<string, any> = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // Additional specific logic for approval status changes\n    if (statusField === 'advisor_status') {\n      // Update the approved_by_advisor flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_advisor = true;\n        updateData.approval_date_advisor = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_advisor = false;\n          updateData.approval_date_advisor = null;\n        }\n      }\n      \n      // CRITICAL: Do NOT update the main status field when making advisor-specific changes\n      // Remove any code that would update 'status' here\n    } \n    else if (statusField === 'company_status') {\n      // Update the approved_by_company flag if status is changing to APPROVED\n      if (status === APPLICATION_STATUS.APPROVED) {\n        updateData.approved_by_company = true;\n        updateData.approval_date_company = new Date().toISOString();\n      } else {\n        // If status is changing from APPROVED to something else, remove the approval\n        if (previousStatus === APPLICATION_STATUS.APPROVED) {\n          updateData.approved_by_company = false;\n          updateData.approval_date_company = null;\n        }\n      }\n      \n      // CRITICAL: Do NOT update the main status field when making company-specific changes\n      // Remove any code that would update 'status' here\n    }\n    else if (statusField === 'status') {\n      // When explicitly updating the main status field, we allow it\n      updateData.status = status;\n    }\n    \n    // Special logic for when both parties have approved\n    if (\n      status === APPLICATION_STATUS.APPROVED &&\n      ((statusField === 'advisor_status' && application.approved_by_company === true) ||\n       (statusField === 'company_status' && application.approved_by_advisor === true))\n    ) {\n      // Both parties have approved, update global_status to POR_DISPERSAR\n      console.log('Both parties have approved, updating global_status to POR_DISPERSAR');\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      \n      // IMPORTANT: Do NOT automatically update the main status field\n      // This should only happen if explicitly using 'status' or 'global_status' statusField\n    }\n    \n    // When using the global_status field, also update the main status to match\n    if (statusField === 'global_status') {\n      updateData.status = status;\n    }\n\n    console.log(`Updating application ${id} ${statusField} to ${status}`, updateData);\n\n    // Update the application\n    const { error: updateError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert([historyEntry]);\n\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n\n    return { \n      success: true, \n      application: { \n        ...application, \n        [statusField]: status,\n        // Include these updated fields in the response so the UI can reflect them\n        ...(statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED \n            ? { approved_by_advisor: true, approval_date_advisor: updateData.approval_date_advisor } \n            : {}),\n        ...(statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED \n            ? { approved_by_company: true, approval_date_company: updateData.approval_date_company } \n            : {})\n      } \n    };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}