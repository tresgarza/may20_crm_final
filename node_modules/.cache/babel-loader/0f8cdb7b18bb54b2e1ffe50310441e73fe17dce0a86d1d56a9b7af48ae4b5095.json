{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\n\n// Local type definitions\n\n// Constants\nconst TABLES = {\n  APPLICATIONS: 'applications',\n  ADVISORS: 'advisors',\n  COMPANIES: 'companies',\n  CLIENTS: 'clients',\n  USERS: 'users'\n};\n\n// Helper function to execute SQL queries\nconst executeQuery = async query => {\n  try {\n    console.log('---------------------------------------------');\n    console.log('EXECUTING QUERY:', query);\n    console.log('---------------------------------------------');\n\n    // Extract table name\n    const tableMatch = query.match(/FROM\\s+([a-zA-Z_][a-zA-Z0-9_]*)/i);\n    const tableName = tableMatch === null || tableMatch === void 0 ? void 0 : tableMatch[1];\n    if (!tableName) {\n      console.error('Could not determine table name from query:', query);\n      return [];\n    }\n    console.log(`Table: ${tableName}`);\n\n    // Define base query\n    let supabaseQuery = supabase.from(tableName).select('*');\n    console.log(`Created base Supabase query for table: ${tableName}`);\n\n    // Define useful query pattern checks\n    const q = query.toLowerCase();\n    const hasCount = q.includes('count(*)');\n    const hasGroupBy = q.includes('group by');\n\n    // Handle simple COUNT queries (without GROUP BY)\n    if (hasCount && !hasGroupBy) {\n      console.log('Processing simple COUNT query (without GROUP BY)...');\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions found: ${conditions}`);\n        try {\n          // Check for common filters and apply them\n          if (conditions.includes('assigned_to =')) {\n            const advisorMatch = conditions.match(/assigned_to\\s*=\\s*'([^']+)'/i);\n            if (advisorMatch && advisorMatch[1]) {\n              supabaseQuery = supabaseQuery.eq('assigned_to', advisorMatch[1]);\n              console.log(`Applied advisor filter: assigned_to = ${advisorMatch[1]}`);\n            }\n          }\n          if (conditions.includes('company_id =')) {\n            const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n            if (companyMatch && companyMatch[1]) {\n              supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n              console.log(`Applied company filter: company_id = ${companyMatch[1]}`);\n            }\n          }\n\n          // Handle date conditions\n          if (conditions.includes('created_at >=')) {\n            const dateMatch = conditions.match(/created_at\\s*>=\\s*'([^']+)'/i);\n            if (dateMatch && dateMatch[1]) {\n              supabaseQuery = supabaseQuery.gte('created_at', dateMatch[1]);\n              console.log(`Applied date filter: created_at >= ${dateMatch[1]}`);\n            }\n          }\n          if (conditions.includes('created_at <=')) {\n            const dateMatch = conditions.match(/created_at\\s*<=\\s*'([^']+)'/i);\n            if (dateMatch && dateMatch[1]) {\n              supabaseQuery = supabaseQuery.lte('created_at', dateMatch[1]);\n              console.log(`Applied date filter: created_at <= ${dateMatch[1]}`);\n            }\n          }\n        } catch (filterError) {\n          console.error('Error applying filters:', filterError);\n        }\n      } else {\n        console.log('No WHERE conditions found in query');\n      }\n\n      // For counts, just fetch all matching data and count it\n      console.log('Executing count query with Supabase...');\n      const {\n        data,\n        error\n      } = await supabaseQuery;\n      if (error) {\n        console.error('Error executing count query:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [{\n          total: 0\n        }];\n      }\n      console.log(`Count result: ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n      return [{\n        total: (data === null || data === void 0 ? void 0 : data.length) || 0\n      }];\n    }\n\n    // Handle status distribution queries\n    if (hasGroupBy && q.includes('group by status')) {\n      console.log('Processing GROUP BY STATUS query...');\n\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for status groups: ${conditions}`);\n\n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for status groups: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n\n      // Get all rows first (with potential filters)\n      console.log('Executing status distribution query with Supabase...');\n      const {\n        data,\n        error\n      } = await supabaseQuery;\n      if (error) {\n        console.error('Error fetching data for status distribution:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      console.log(`Status distribution query returned ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n\n      // Process the data to get status counts\n      const statusCounts = {};\n      data === null || data === void 0 ? void 0 : data.forEach(row => {\n        const status = row.status || 'unknown';\n        statusCounts[status] = (statusCounts[status] || 0) + 1;\n      });\n\n      // Convert to array of status and count\n      const result = Object.entries(statusCounts).map(([status, count]) => ({\n        status,\n        count\n      }));\n      console.log('Status distribution result:', result);\n      return result;\n    }\n\n    // Handle SUM/AVG queries\n    if (q.includes('sum(amount)') || q.includes('avg(amount)')) {\n      console.log('Processing SUM/AVG query...');\n\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for amount calculation: ${conditions}`);\n\n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for amount calculation: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      console.log('Executing amount calculation query with Supabase...');\n      const {\n        data,\n        error\n      } = await supabaseQuery;\n      if (error) {\n        console.error('Error fetching data for amount calculations:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [{\n          total_amount: 0,\n          avg_amount: 0\n        }];\n      }\n      console.log(`Amount calculation query returned ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n      console.log('Raw amount data sample:', data === null || data === void 0 ? void 0 : data.slice(0, 3));\n\n      // Process data to calculate sum and average\n      const amounts = (data === null || data === void 0 ? void 0 : data.filter(row => {\n        const validAmount = row.amount !== null && !isNaN(Number(row.amount));\n        if (!validAmount) {\n          console.log(`Filtering out invalid amount value:`, row.amount);\n        }\n        return validAmount;\n      }).map(row => {\n        const amount = Number(row.amount);\n        console.log(`Converting amount ${row.amount} to number: ${amount}`);\n        return amount;\n      })) || [];\n      const totalAmount = amounts.reduce((sum, amount) => {\n        console.log(`Adding ${amount} to sum ${sum}`);\n        return sum + amount;\n      }, 0);\n      const avgAmount = amounts.length > 0 ? totalAmount / amounts.length : 0;\n      console.log(`Amount calculations - Total: ${totalAmount}, Average: ${avgAmount}, Count: ${amounts.length}`);\n      return [{\n        total_amount: totalAmount,\n        avg_amount: avgAmount\n      }];\n    }\n\n    // Handle recent applications query\n    if (q.includes('order by created_at desc') && q.includes('limit')) {\n      console.log('Processing RECENT APPLICATIONS query...');\n\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+ORDER BY|\\s+LIMIT|$)/i);\n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for recent applications: ${conditions}`);\n\n        // Apply filters\n        if (conditions.includes('company_id =') || conditions.includes('a.company_id =')) {\n          const companyMatch = conditions.match(/(?:a\\.)?company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for recent applications: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n\n      // Extract limit value\n      const limitMatch = query.match(/LIMIT\\s+(\\d+)/i);\n      const limit = limitMatch ? parseInt(limitMatch[1], 10) : 5;\n\n      // Apply ordering and limit\n      console.log(`Executing recent applications query with limit ${limit}...`);\n      supabaseQuery = supabaseQuery.order('created_at', {\n        ascending: false\n      }).limit(limit);\n\n      // Execute query\n      const {\n        data,\n        error\n      } = await supabaseQuery;\n      if (error) {\n        console.error('Error fetching recent applications:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      console.log(`Recent applications query returned ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n      console.log('Recent applications sample:', data === null || data === void 0 ? void 0 : data.slice(0, 1));\n      return data || [];\n    }\n\n    // Handle applications by month\n    if (q.includes(\"to_char(created_at, 'yyyy-mm')\") && hasGroupBy) {\n      console.log('Processing APPLICATIONS BY MONTH query...');\n\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for applications by month: ${conditions}`);\n\n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for applications by month: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      console.log('Executing applications by month query with Supabase...');\n      const {\n        data,\n        error\n      } = await supabaseQuery;\n      if (error) {\n        console.error('Error fetching data for monthly breakdown:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      console.log(`Applications by month query returned ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n\n      // Process data to get counts by month\n      const monthCounts = {};\n      data === null || data === void 0 ? void 0 : data.forEach(row => {\n        try {\n          const date = new Date(row.created_at);\n          const monthYear = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          monthCounts[monthYear] = (monthCounts[monthYear] || 0) + 1;\n        } catch (dateError) {\n          console.error('Error processing date:', row.created_at, dateError);\n        }\n      });\n\n      // Convert to expected format\n      const result = Object.entries(monthCounts).map(([month, count]) => ({\n        month,\n        count\n      }));\n      console.log('Applications by month result:', result);\n      return result;\n    }\n\n    // Default case - just fetch the data\n    console.log('Executing default query...');\n\n    // Extract WHERE conditions if they exist\n    const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n    if (whereMatch && whereMatch[1]) {\n      const conditions = whereMatch[1];\n      console.log(`WHERE conditions for default query: ${conditions}`);\n\n      // Apply filters\n      if (conditions.includes('company_id =')) {\n        const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n        if (companyMatch && companyMatch[1]) {\n          supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n          console.log(`Applied company filter for default query: company_id = ${companyMatch[1]}`);\n        }\n      }\n    }\n    const {\n      data,\n      error\n    } = await supabaseQuery;\n    if (error) {\n      console.error('Error executing query:', error);\n      console.error('Error details:', JSON.stringify(error, null, 2));\n      return [];\n    }\n    console.log(`Query returned ${(data === null || data === void 0 ? void 0 : data.length) || 0} items`);\n    return data || [];\n  } catch (err) {\n    console.error('Error handling query execution:', err);\n    console.error('Error stack:', err instanceof Error ? err.stack : 'Unknown error');\n    return [];\n  }\n};\n\n/**\n * Get general dashboard stats based on filters\n */\nexport const getGeneralDashboardStats = async filters => {\n  try {\n    var _totalApplicationsRes, _amountResult$, _amountResult$2;\n    // Filter conditions\n    let filterConditions = '';\n    const conditions = [];\n    if (filters.advisorId) {\n      conditions.push(`assigned_to = '${filters.advisorId}'`);\n    }\n    if (filters.companyId) {\n      conditions.push(`company_id = '${filters.companyId}'`);\n    }\n    if (filters.startDate) {\n      conditions.push(`created_at >= '${filters.startDate}'`);\n    }\n    if (filters.endDate) {\n      conditions.push(`created_at <= '${filters.endDate}'`);\n    }\n    if (conditions.length > 0) {\n      filterConditions = ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    // Get total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n    `;\n    const totalApplicationsResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(((_totalApplicationsRes = totalApplicationsResult[0]) === null || _totalApplicationsRes === void 0 ? void 0 : _totalApplicationsRes.total) || '0');\n\n    // Get applications by status\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY status\n    `;\n    const applicationsByStatusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = {};\n    if (applicationsByStatusResult && Array.isArray(applicationsByStatusResult)) {\n      applicationsByStatusResult.forEach(item => {\n        if (!item || !item.status) return;\n        const status = item.status;\n        let count = 0;\n        if (typeof item.count === 'number') {\n          count = item.count;\n        } else if (typeof item.count === 'string') {\n          count = parseInt(item.count, 10) || 0;\n        } else if (item.count) {\n          count = parseInt(String(item.count), 10) || 0;\n        }\n        applicationsByStatus[status] = count;\n      });\n    }\n\n    // Calcular aplicaciones aprobadas, rechazadas y pendientes\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    const pendingApplications = applicationsByStatus['pending'] || 0;\n\n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n    `;\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = parseFloat(((_amountResult$ = amountResult[0]) === null || _amountResult$ === void 0 ? void 0 : _amountResult$.total_amount) || '0');\n    const averageAmount = parseFloat(((_amountResult$2 = amountResult[0]) === null || _amountResult$2 === void 0 ? void 0 : _amountResult$2.avg_amount) || '0');\n\n    // Get recent applications\n    const recentApplicationsQuery = `\n      SELECT *\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;\n    const recentApplicationsResult = await executeQuery(recentApplicationsQuery);\n    const recentApplications = recentApplicationsResult;\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY month \n      ORDER BY month\n    `;\n    const applicationsByMonthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = applicationsByMonthResult.map(item => ({\n      month: item.month,\n      count: parseInt(item.count)\n    }));\n\n    // Get advisor performance\n    const advisorPerformanceQuery = `\n        SELECT \n        assigned_to as advisor_id,\n          COUNT(*) as total_applications,\n        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved_applications\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY assigned_to\n    `;\n    const advisorPerformanceResult = await executeQuery(advisorPerformanceQuery);\n    const advisorPerformance = advisorPerformanceResult.map(item => {\n      const applications = parseInt(item.total_applications);\n      const approvedApplications = parseInt(item.approved_applications);\n      return {\n        advisorId: item.advisor_id,\n        applications,\n        approvalRate: applications > 0 ? approvedApplications / applications * 100 : 0\n      };\n    });\n    return {\n      totalApplications,\n      pendingApplications,\n      approvedApplications,\n      rejectedApplications,\n      totalAmount,\n      averageAmount,\n      recentApplications,\n      applicationsByMonth,\n      applicationsByStatus,\n      advisorPerformance\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Map a raw status string to a normalized dashboard status\n */\nconst mapToDashboardStatus = raw => {\n  if (!raw) return 'pending';\n  const status = raw.toLowerCase();\n  if (status === 'new' || status === 'solicitud' || status === 'pending') {\n    return 'pending';\n  } else if (status === 'in_review') {\n    return 'in_review';\n  } else if (status === 'approved' || status === 'por_dispersar' || status === 'completed') {\n    return 'approved';\n  } else if (status === 'rejected' || status === 'cancelled' || status === 'expired') {\n    return 'rejected';\n  }\n  return 'pending'; // Default fallback\n};\n\n/**\n * Normalize application status to one of the four dashboard categories:\n * pending, in_review, approved, rejected\n */\nconst normalizeApplicationStatus = status => {\n  return mapToDashboardStatus(status);\n};\n\n/**\n * Get stats for a specific advisor\n */\nexport const getAdvisorStats = async (advisorId, filters = {}) => {\n  console.log(`Getting advisor stats for advisorId: ${advisorId} with filters:`, filters);\n  try {\n    var _advisorStats$recent;\n    // Get advisor details to construct the name\n    const advisorQuery = `\n      SELECT a.id, a.email, a.name, a.access_code, u.first_name, u.last_name, u.email as user_email\n      FROM ${TABLES.ADVISORS} a\n      LEFT JOIN ${TABLES.USERS} u ON a.email = u.email\n      WHERE a.id = '${advisorId}'\n    `;\n    const advisorResult = await executeQuery(advisorQuery);\n    if (!advisorResult || !advisorResult.length || !advisorResult[0]) {\n      console.error(`No advisor found with ID: ${advisorId}`);\n      throw new Error(`No advisor found with ID: ${advisorId}`);\n    }\n    const advisor = advisorResult[0];\n    console.log(`Found advisor:`, advisor);\n\n    // Get the applications by status\n    const applicationsByStatusQuery = `\n      SELECT \n        status,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n      GROUP BY status\n    `;\n\n    // Execute the query and get the results\n    const statusResults = await executeQuery(applicationsByStatusQuery);\n    console.log('Status query results:', statusResults);\n\n    // Initialize the applicationsByStatus with default values\n    const applicationsByStatus = {\n      'pending': 0,\n      'in_review': 0,\n      'approved': 0,\n      'rejected': 0\n    };\n\n    // Map them to the normalized dashboard statuses\n    if (statusResults && Array.isArray(statusResults)) {\n      statusResults.forEach(result => {\n        if (result && typeof result === 'object' && 'status' in result && 'count' in result) {\n          const status = String(result.status || '');\n          const count = typeof result.count === 'number' ? result.count : result.count ? Number(result.count) : 0;\n\n          // Using the normalized status\n          const normalizedStatus = normalizeApplicationStatus(status);\n\n          // Add to the appropriate status count (defensively)\n          if (normalizedStatus && applicationsByStatus[normalizedStatus] !== undefined) {\n            applicationsByStatus[normalizedStatus] += count;\n          }\n          console.log(`Mapped status ${status} (normalized: ${normalizedStatus}) with count ${count}`);\n        }\n      });\n    }\n    console.log('Final applicationsByStatus:', applicationsByStatus);\n\n    // Calculate total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n    `;\n    const totalResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = totalResult && totalResult[0] ? Number(totalResult[0].count || 0) : 0;\n    console.log(`Total applications: ${totalApplications}`);\n\n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n    `;\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = amountResult && amountResult[0] ? Number(amountResult[0].total_amount || 0) : 0;\n    const averageAmount = amountResult && amountResult[0] ? Number(amountResult[0].avg_amount || 0) : 0;\n    console.log(`Total amount: ${totalAmount}, Average amount: ${averageAmount}`);\n\n    // Prepare the application by status chart data (array format for charts)\n    const applicationsByStatusChart = Object.entries(applicationsByStatus).map(([status, count]) => ({\n      status,\n      count\n    }));\n    console.log('applicationsByStatusChart array format:', applicationsByStatusChart);\n\n    // Calculate the conversion rate (approved / total)\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    const pendingApplications = (applicationsByStatus['pending'] || 0) + (applicationsByStatus['in_review'] || 0);\n    const conversionRate = totalApplications > 0 ? Number((approvedApplications / totalApplications * 100).toFixed(2)) : 0;\n    console.log(`Calculated conversion rate: ${conversionRate}%`);\n\n    // Create the advisor stats object\n    const advisorStats = {\n      advisorId,\n      advisorName: advisor.name || `${advisor.first_name || ''} ${advisor.last_name || ''}`.trim() || advisor.email,\n      totalApplications,\n      approvedApplications,\n      rejectedApplications,\n      pendingApplications,\n      totalAmount,\n      averageAmount,\n      conversionRate,\n      applicationsByStatus,\n      applicationsByStatusChart,\n      applicationsByMonth: [],\n      // Will be populated later if needed\n      recent: [],\n      // Will be populated later if needed\n\n      // Add missing required properties from the ApplicationStats interface\n      recentApplications: [],\n      // This will be filled later if needed\n      advisorPerformance: [],\n      // Not applicable for single advisor stats\n      totalApproved: approvedApplications,\n      totalRejected: rejectedApplications,\n      totalPending: pendingApplications,\n      pendingApproval: 0,\n      // This would need to be calculated separately if needed\n      totalClients: 0,\n      // Would need a separate query to get this\n      totalCompanies: 0,\n      // Would need a separate query to get this\n      avgTimeToApproval: 0 // Would need a separate query to calculate this\n    };\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResults = await executeQuery(applicationsByMonthQuery);\n    if (monthResults && Array.isArray(monthResults)) {\n      advisorStats.applicationsByMonth = monthResults.map(result => ({\n        month: String(result.month || ''),\n        count: typeof result.count === 'number' ? result.count : Number(result.count || 0)\n      }));\n    }\n    console.log(`Applications by month (${advisorStats.applicationsByMonth.length} entries)`, advisorStats.applicationsByMonth);\n\n    // Get recent applications\n    const recentApplicationsQuery = `\n      SELECT a.*, c.name as company_name\n      FROM ${TABLES.APPLICATIONS} a\n      LEFT JOIN ${TABLES.COMPANIES} c ON a.company_id = c.id\n      WHERE a.assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND a.created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND a.created_at <= '${filters.endDate}'` : ''}\n      ORDER BY a.created_at DESC\n      LIMIT 5\n    `;\n    const recentResults = await executeQuery(recentApplicationsQuery);\n    if (recentResults && Array.isArray(recentResults)) {\n      advisorStats.recent = recentResults;\n      advisorStats.recentApplications = recentResults; // Also populate the recentApplications field\n    }\n    console.log(`Recent applications (${((_advisorStats$recent = advisorStats.recent) === null || _advisorStats$recent === void 0 ? void 0 : _advisorStats$recent.length) || 0} entries)`, advisorStats.recent || []);\n    return advisorStats;\n  } catch (error) {\n    console.error('Error getting advisor stats:', error);\n    throw error;\n  }\n};\n\n/**\n * Get stats for a specific company\n */\nexport const getCompanyDashboardStats = async (companyId, filters) => {\n  try {\n    var _totalApplicationsRes2, _amountResult$3, _amountResult$4, _totalClientsResult$, _totalAdvisorsResult$, _avgApprovalTimeResul;\n    console.log('=====================================================');\n    console.log(`COMPANY DASHBOARD STATS - Company ID: ${companyId}`);\n    console.log('=====================================================');\n    console.log('Filters:', JSON.stringify(filters));\n\n    // Filter conditions for date range\n    let dateFilterConditions = '';\n    const dateConditions = [];\n    if (filters.startDate) {\n      dateConditions.push(`created_at >= '${filters.startDate}'`);\n    }\n    if (filters.endDate) {\n      dateConditions.push(`created_at <= '${filters.endDate}'`);\n    }\n    if (dateConditions.length > 0) {\n      dateFilterConditions = ` AND ${dateConditions.join(' AND ')}`;\n    }\n\n    // Base filter for company\n    const baseFilter = `company_id = '${companyId}'${dateFilterConditions}`;\n    console.log(`SQL base filter: ${baseFilter}`);\n\n    // Get total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching total applications...');\n    const totalApplicationsResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(((_totalApplicationsRes2 = totalApplicationsResult[0]) === null || _totalApplicationsRes2 === void 0 ? void 0 : _totalApplicationsRes2.total) || '0');\n    console.log(`Total applications: ${totalApplications}`);\n\n    // Get applications by status\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      GROUP BY status\n    `;\n    console.log('Fetching applications by status...');\n    const applicationsByStatusResult = await executeQuery(applicationsByStatusQuery);\n    console.log('Applications by status raw result:', applicationsByStatusResult);\n\n    // Convert the result to the required format and calculate totals by status\n    const statusMap = {};\n    const applicationsByStatus = [];\n    if (applicationsByStatusResult && Array.isArray(applicationsByStatusResult)) {\n      applicationsByStatusResult.forEach(item => {\n        if (!item) return;\n        const status = item.status || 'unknown';\n        let count = 0;\n        if (typeof item.count === 'number') {\n          count = item.count;\n        } else if (typeof item.count === 'string') {\n          count = parseInt(item.count, 10) || 0;\n        } else if (item.count) {\n          count = parseInt(String(item.count), 10) || 0;\n        }\n\n        // Store in a map for easy access\n        statusMap[status] = count;\n\n        // Also add to the array format\n        applicationsByStatus.push({\n          status,\n          count\n        });\n      });\n    }\n\n    // Get the counts for specific statuses - defaulting to 0 if not found\n    const approvedApplications = statusMap['approved'] || 0;\n    const rejectedApplications = statusMap['rejected'] || 0;\n    const pendingApplications = statusMap['pending'] || 0;\n    console.log('Status totals:', {\n      approved: approvedApplications,\n      rejected: rejectedApplications,\n      pending: pendingApplications\n    });\n\n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching amount totals...');\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = parseFloat(((_amountResult$3 = amountResult[0]) === null || _amountResult$3 === void 0 ? void 0 : _amountResult$3.total_amount) || '0');\n    const avgAmount = parseFloat(((_amountResult$4 = amountResult[0]) === null || _amountResult$4 === void 0 ? void 0 : _amountResult$4.avg_amount) || '0');\n    console.log(`Amount totals: total=${totalAmount}, average=${avgAmount}`);\n\n    // Get recent applications with advisor info\n    const recentApplicationsQuery = `\n      SELECT a.*, adv.id as advisor_id, adv.user_id, adv.specialization\n      FROM ${TABLES.APPLICATIONS} a\n      LEFT JOIN ${TABLES.ADVISORS} adv ON a.assigned_to = adv.user_id\n      WHERE a.${baseFilter}\n      ORDER BY a.created_at DESC\n      LIMIT 5\n    `;\n    console.log('Fetching recent applications...');\n    const recentApplicationsResult = await executeQuery(recentApplicationsQuery);\n    console.log(`Retrieved ${recentApplicationsResult.length} recent applications`);\n\n    // Map the results to include advisor info\n    const recentApplications = recentApplicationsResult.map(app => {\n      // Check if app has advisor-related fields\n      const hasAdvisorInfo = !!app.advisor_id;\n      console.log(`Application ${app.id} has advisor info: ${hasAdvisorInfo}`);\n      return {\n        ...app,\n        advisor: hasAdvisorInfo ? {\n          id: app.advisor_id,\n          user_id: app.user_id,\n          specialization: app.specialization\n        } : null\n      };\n    });\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      GROUP BY month\n      ORDER BY month\n    `;\n    console.log('Fetching applications by month...');\n    const applicationsByMonthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = applicationsByMonthResult.map(item => ({\n      month: item.month || '',\n      count: parseInt(String(item.count), 10) || 0 // Ensure count is always a number\n    }));\n    console.log(`Retrieved ${applicationsByMonth.length} months of application data`);\n\n    // Get total unique clients\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT client_id) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching total clients...');\n    const totalClientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(((_totalClientsResult$ = totalClientsResult[0]) === null || _totalClientsResult$ === void 0 ? void 0 : _totalClientsResult$.total) || '0');\n    console.log(`Total clients: ${totalClients}`);\n\n    // Get total advisors for this company\n    const totalAdvisorsQuery = `\n      SELECT COUNT(*) as total\n      FROM ${TABLES.ADVISORS}\n      WHERE company_id = '${companyId}'\n    `;\n    console.log('Fetching total advisors...');\n    const totalAdvisorsResult = await executeQuery(totalAdvisorsQuery);\n    const totalAdvisors = parseInt(((_totalAdvisorsResult$ = totalAdvisorsResult[0]) === null || _totalAdvisorsResult$ === void 0 ? void 0 : _totalAdvisorsResult$.total) || '0');\n    console.log(`Total advisors: ${totalAdvisors}`);\n\n    // Calculate average time to approval for company\n    const avgApprovalTimeQuery = `\n      SELECT AVG(\n        EXTRACT(EPOCH FROM (approval_date_company - created_at)) / 3600\n      ) as avg_time\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      AND approval_date_company IS NOT NULL\n    `;\n    console.log('Fetching average approval time...');\n    const avgApprovalTimeResult = await executeQuery(avgApprovalTimeQuery);\n    const avgApprovalTime = parseFloat(((_avgApprovalTimeResul = avgApprovalTimeResult[0]) === null || _avgApprovalTimeResul === void 0 ? void 0 : _avgApprovalTimeResul.avg_time) || '0');\n    console.log(`Average approval time: ${avgApprovalTime} hours`);\n\n    // Get advisor performance for this company\n    try {\n      const advisorPerformanceQuery = `\n        SELECT \n          a.assigned_to as advisor_id,\n          u.first_name || ' ' || u.last_name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications,\n          SUM(CASE WHEN a.status = 'pending' THEN 1 ELSE 0 END) as pending_applications,\n          AVG(\n            CASE \n              WHEN a.approval_date_advisor IS NOT NULL \n              THEN EXTRACT(EPOCH FROM (a.approval_date_advisor - a.created_at)) / 3600\n              ELSE NULL\n            END\n          ) as avg_approval_time\n        FROM ${TABLES.APPLICATIONS} a\n        JOIN ${TABLES.USERS} u ON a.assigned_to = u.id\n        WHERE a.${baseFilter}\n        GROUP BY a.assigned_to, u.first_name, u.last_name\n      `;\n      console.log('Fetching advisor performance...');\n      const advisorPerformanceResult = await executeQuery(advisorPerformanceQuery);\n      console.log(`Retrieved advisor performance for ${advisorPerformanceResult.length} advisors`);\n      const advisorPerformance = advisorPerformanceResult.map(item => {\n        const totalApplications = parseInt(item.total_applications || '0');\n        const approvedApplications = parseInt(item.approved_applications || '0');\n        const rejectedApplications = parseInt(item.rejected_applications || '0');\n        const pendingApplications = parseInt(item.pending_applications || '0');\n        return {\n          advisorId: item.advisor_id || '',\n          advisorName: item.advisor_name || '',\n          totalApplications,\n          approvedApplications,\n          rejectedApplications,\n          pendingApplications,\n          approvalRate: totalApplications > 0 ? approvedApplications / totalApplications * 100 : 0,\n          avgApprovalTime: parseFloat(item.avg_approval_time || '0')\n        };\n      });\n\n      // Build the final result object\n      const result = {\n        totalApplications,\n        pendingApplications,\n        approvedApplications,\n        rejectedApplications,\n        totalAmount,\n        avgAmount,\n        recentApplications,\n        applicationsByMonth,\n        applicationsByStatus,\n        advisorPerformance,\n        totalClients,\n        totalAdvisors,\n        avgApprovalTime\n      };\n      console.log('Successfully compiled complete company dashboard stats');\n      return result;\n    } catch (error) {\n      console.error('Error in advisor performance section:', error);\n      console.error('Error stack:', error instanceof Error ? error.stack : 'Unknown error');\n\n      // Return data without advisor performance if there's an error\n      const result = {\n        totalApplications,\n        pendingApplications,\n        approvedApplications,\n        rejectedApplications,\n        totalAmount,\n        avgAmount,\n        recentApplications,\n        applicationsByMonth,\n        applicationsByStatus,\n        advisorPerformance: [],\n        totalClients,\n        totalAdvisors,\n        avgApprovalTime\n      };\n      console.log('Returning company dashboard stats without advisor performance due to error');\n      return result;\n    }\n  } catch (error) {\n    console.error('Error getting company dashboard stats:', error);\n    console.error('Error stack:', error instanceof Error ? error.stack : 'Unknown error');\n    throw error;\n  }\n};\n\n/**\n * Get pending approvals for user\n */\nexport const getPendingApprovals = async (userId, isCompanyAdmin) => {\n  try {\n    var _result$;\n    let query = '';\n    if (isCompanyAdmin) {\n      // Aplicaciones pendientes de aprobación por la empresa\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${userId}'\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    const result = await executeQuery(query);\n    const totalPending = parseInt(((_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.pending_count) || '0');\n\n    // Obtener aplicaciones pendientes de aprobación\n    const pendingApplicationsQuery = `\n      SELECT *\n      FROM ${TABLES.APPLICATIONS}\n      WHERE ${isCompanyAdmin ? 'company_id' : 'assigned_to'} = '${userId}'\n      AND ${isCompanyAdmin ? 'approved_by_company = false' : 'approved_by_advisor = false'}\n    `;\n    const pendingApplicationsResult = await executeQuery(pendingApplicationsQuery);\n    const pendingApplications = pendingApplicationsResult.map(app => ({\n      ...app,\n      approval_date_company: app.approval_date_company ? new Date(app.approval_date_company).toISOString() : null,\n      approval_date_advisor: app.approval_date_advisor ? new Date(app.approval_date_advisor).toISOString() : null\n    }));\n    return {\n      totalPending,\n      pendingApplications\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["supabase","TABLES","APPLICATIONS","ADVISORS","COMPANIES","CLIENTS","USERS","executeQuery","query","console","log","tableMatch","match","tableName","error","supabaseQuery","from","select","q","toLowerCase","hasCount","includes","hasGroupBy","whereMatch","conditions","advisorMatch","eq","companyMatch","dateMatch","gte","lte","filterError","data","JSON","stringify","total","length","statusCounts","forEach","row","status","result","Object","entries","map","count","total_amount","avg_amount","slice","amounts","filter","validAmount","amount","isNaN","Number","totalAmount","reduce","sum","avgAmount","limitMatch","limit","parseInt","order","ascending","monthCounts","date","Date","created_at","monthYear","getFullYear","String","getMonth","padStart","dateError","month","err","Error","stack","getGeneralDashboardStats","filters","_totalApplicationsRes","_amountResult$","_amountResult$2","filterConditions","advisorId","push","companyId","startDate","endDate","join","totalApplicationsQuery","totalApplicationsResult","totalApplications","applicationsByStatusQuery","applicationsByStatusResult","applicationsByStatus","Array","isArray","item","approvedApplications","rejectedApplications","pendingApplications","amountQuery","amountResult","parseFloat","averageAmount","recentApplicationsQuery","recentApplicationsResult","recentApplications","applicationsByMonthQuery","applicationsByMonthResult","applicationsByMonth","advisorPerformanceQuery","advisorPerformanceResult","advisorPerformance","applications","total_applications","approved_applications","advisor_id","approvalRate","mapToDashboardStatus","raw","normalizeApplicationStatus","getAdvisorStats","_advisorStats$recent","advisorQuery","advisorResult","advisor","statusResults","normalizedStatus","undefined","totalResult","applicationsByStatusChart","conversionRate","toFixed","advisorStats","advisorName","name","first_name","last_name","trim","email","recent","totalApproved","totalRejected","totalPending","pendingApproval","totalClients","totalCompanies","avgTimeToApproval","monthResults","recentResults","getCompanyDashboardStats","_totalApplicationsRes2","_amountResult$3","_amountResult$4","_totalClientsResult$","_totalAdvisorsResult$","_avgApprovalTimeResul","dateFilterConditions","dateConditions","baseFilter","statusMap","approved","rejected","pending","app","hasAdvisorInfo","id","user_id","specialization","totalClientsQuery","totalClientsResult","totalAdvisorsQuery","totalAdvisorsResult","totalAdvisors","avgApprovalTimeQuery","avgApprovalTimeResult","avgApprovalTime","avg_time","rejected_applications","pending_applications","advisor_name","avg_approval_time","getPendingApprovals","userId","isCompanyAdmin","_result$","pending_count","pendingApplicationsQuery","pendingApplicationsResult","approval_date_company","toISOString","approval_date_advisor"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { \n  DashboardStats, \n  ApplicationStats, \n  AdvisorPerformance, \n  AdvisorPerformanceStats,\n  CompanyStats,\n  QueryResult,\n  QueryFilters\n} from '../types/dashboard.types';\nimport type { Database } from '../types/database.types';\n\n// Local type definitions\ntype Tables = Database['public']['Tables'];\ntype Application = Tables['applications']['Row'];\n\n// Constants\nconst TABLES = {\n  APPLICATIONS: 'applications',\n  ADVISORS: 'advisors',\n  COMPANIES: 'companies',\n  CLIENTS: 'clients',\n  USERS: 'users'\n};\n\n// Helper function to execute SQL queries\nconst executeQuery = async (query: string): Promise<any[]> => {\n  try {\n    console.log('---------------------------------------------');\n    console.log('EXECUTING QUERY:', query);\n    console.log('---------------------------------------------');\n    \n    // Extract table name\n    const tableMatch = query.match(/FROM\\s+([a-zA-Z_][a-zA-Z0-9_]*)/i);\n    const tableName = tableMatch?.[1];\n    \n    if (!tableName) {\n      console.error('Could not determine table name from query:', query);\n      return [];\n    }\n\n    console.log(`Table: ${tableName}`);\n    \n    // Define base query\n    let supabaseQuery = supabase.from(tableName).select('*');\n    console.log(`Created base Supabase query for table: ${tableName}`);\n    \n    // Define useful query pattern checks\n    const q = query.toLowerCase();\n    const hasCount = q.includes('count(*)');\n    const hasGroupBy = q.includes('group by');\n    \n    // Handle simple COUNT queries (without GROUP BY)\n    if (hasCount && !hasGroupBy) {\n      console.log('Processing simple COUNT query (without GROUP BY)...');\n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      \n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions found: ${conditions}`);\n        \n        try {\n          // Check for common filters and apply them\n          if (conditions.includes('assigned_to =')) {\n            const advisorMatch = conditions.match(/assigned_to\\s*=\\s*'([^']+)'/i);\n            if (advisorMatch && advisorMatch[1]) {\n              supabaseQuery = supabaseQuery.eq('assigned_to', advisorMatch[1]);\n              console.log(`Applied advisor filter: assigned_to = ${advisorMatch[1]}`);\n            }\n          }\n          \n          if (conditions.includes('company_id =')) {\n            const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n            if (companyMatch && companyMatch[1]) {\n              supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n              console.log(`Applied company filter: company_id = ${companyMatch[1]}`);\n            }\n          }\n          \n          // Handle date conditions\n          if (conditions.includes('created_at >=')) {\n            const dateMatch = conditions.match(/created_at\\s*>=\\s*'([^']+)'/i);\n            if (dateMatch && dateMatch[1]) {\n              supabaseQuery = supabaseQuery.gte('created_at', dateMatch[1]);\n              console.log(`Applied date filter: created_at >= ${dateMatch[1]}`);\n            }\n          }\n          \n          if (conditions.includes('created_at <=')) {\n            const dateMatch = conditions.match(/created_at\\s*<=\\s*'([^']+)'/i);\n            if (dateMatch && dateMatch[1]) {\n              supabaseQuery = supabaseQuery.lte('created_at', dateMatch[1]);\n              console.log(`Applied date filter: created_at <= ${dateMatch[1]}`);\n            }\n          }\n        } catch (filterError) {\n          console.error('Error applying filters:', filterError);\n        }\n      } else {\n        console.log('No WHERE conditions found in query');\n      }\n      \n      // For counts, just fetch all matching data and count it\n      console.log('Executing count query with Supabase...');\n      const { data, error } = await supabaseQuery;\n      \n      if (error) {\n        console.error('Error executing count query:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [{ total: 0 }];\n      }\n      \n      console.log(`Count result: ${data?.length || 0} items`);\n      return [{ total: data?.length || 0 }];\n    }\n    \n    // Handle status distribution queries\n    if (hasGroupBy && q.includes('group by status')) {\n      console.log('Processing GROUP BY STATUS query...');\n      \n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      \n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for status groups: ${conditions}`);\n        \n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for status groups: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      \n      // Get all rows first (with potential filters)\n      console.log('Executing status distribution query with Supabase...');\n      const { data, error } = await supabaseQuery;\n      \n      if (error) {\n        console.error('Error fetching data for status distribution:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      \n      console.log(`Status distribution query returned ${data?.length || 0} items`);\n      \n      // Process the data to get status counts\n      const statusCounts: Record<string, number> = {};\n      \n      data?.forEach(row => {\n        const status = row.status || 'unknown';\n        statusCounts[status] = (statusCounts[status] || 0) + 1;\n      });\n      \n      // Convert to array of status and count\n      const result = Object.entries(statusCounts).map(([status, count]) => ({\n        status,\n        count\n      }));\n      \n      console.log('Status distribution result:', result);\n      return result;\n    }\n    \n    // Handle SUM/AVG queries\n    if (q.includes('sum(amount)') || q.includes('avg(amount)')) {\n      console.log('Processing SUM/AVG query...');\n      \n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      \n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for amount calculation: ${conditions}`);\n        \n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for amount calculation: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      \n      console.log('Executing amount calculation query with Supabase...');\n      const { data, error } = await supabaseQuery;\n      \n      if (error) {\n        console.error('Error fetching data for amount calculations:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [{ total_amount: 0, avg_amount: 0 }];\n      }\n      \n      console.log(`Amount calculation query returned ${data?.length || 0} items`);\n      console.log('Raw amount data sample:', data?.slice(0, 3));\n      \n      // Process data to calculate sum and average\n      const amounts = data\n        ?.filter(row => {\n          const validAmount = row.amount !== null && !isNaN(Number(row.amount));\n          if (!validAmount) {\n            console.log(`Filtering out invalid amount value:`, row.amount);\n          }\n          return validAmount;\n        })\n        .map(row => {\n          const amount = Number(row.amount);\n          console.log(`Converting amount ${row.amount} to number: ${amount}`);\n          return amount;\n        }) || [];\n      \n      const totalAmount = amounts.reduce((sum, amount) => {\n        console.log(`Adding ${amount} to sum ${sum}`);\n        return sum + amount;\n      }, 0);\n      const avgAmount = amounts.length > 0 ? totalAmount / amounts.length : 0;\n      \n      console.log(`Amount calculations - Total: ${totalAmount}, Average: ${avgAmount}, Count: ${amounts.length}`);\n      return [{ total_amount: totalAmount, avg_amount: avgAmount }];\n    }\n    \n    // Handle recent applications query\n    if (q.includes('order by created_at desc') && q.includes('limit')) {\n      console.log('Processing RECENT APPLICATIONS query...');\n      \n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+ORDER BY|\\s+LIMIT|$)/i);\n      \n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for recent applications: ${conditions}`);\n        \n        // Apply filters\n        if (conditions.includes('company_id =') || conditions.includes('a.company_id =')) {\n          const companyMatch = conditions.match(/(?:a\\.)?company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for recent applications: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      \n      // Extract limit value\n      const limitMatch = query.match(/LIMIT\\s+(\\d+)/i);\n      const limit = limitMatch ? parseInt(limitMatch[1], 10) : 5;\n      \n      // Apply ordering and limit\n      console.log(`Executing recent applications query with limit ${limit}...`);\n      supabaseQuery = supabaseQuery.order('created_at', { ascending: false }).limit(limit);\n      \n      // Execute query\n      const { data, error } = await supabaseQuery;\n      \n      if (error) {\n        console.error('Error fetching recent applications:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      \n      console.log(`Recent applications query returned ${data?.length || 0} items`);\n      console.log('Recent applications sample:', data?.slice(0, 1));\n      return data || [];\n    }\n    \n    // Handle applications by month\n    if (q.includes(\"to_char(created_at, 'yyyy-mm')\") && hasGroupBy) {\n      console.log('Processing APPLICATIONS BY MONTH query...');\n      \n      // Extract WHERE conditions if they exist\n      const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n      \n      if (whereMatch && whereMatch[1]) {\n        const conditions = whereMatch[1];\n        console.log(`WHERE conditions for applications by month: ${conditions}`);\n        \n        // Apply filters\n        if (conditions.includes('company_id =')) {\n          const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n          if (companyMatch && companyMatch[1]) {\n            supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n            console.log(`Applied company filter for applications by month: company_id = ${companyMatch[1]}`);\n          }\n        }\n      }\n      \n      console.log('Executing applications by month query with Supabase...');\n      const { data, error } = await supabaseQuery;\n      \n      if (error) {\n        console.error('Error fetching data for monthly breakdown:', error);\n        console.error('Error details:', JSON.stringify(error, null, 2));\n        return [];\n      }\n      \n      console.log(`Applications by month query returned ${data?.length || 0} items`);\n      \n      // Process data to get counts by month\n      const monthCounts: Record<string, number> = {};\n      \n      data?.forEach(row => {\n        try {\n          const date = new Date(row.created_at);\n          const monthYear = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          monthCounts[monthYear] = (monthCounts[monthYear] || 0) + 1;\n        } catch (dateError) {\n          console.error('Error processing date:', row.created_at, dateError);\n        }\n      });\n      \n      // Convert to expected format\n      const result = Object.entries(monthCounts).map(([month, count]) => ({\n        month,\n        count\n      }));\n      \n      console.log('Applications by month result:', result);\n      return result;\n    }\n    \n    // Default case - just fetch the data\n    console.log('Executing default query...');\n    \n    // Extract WHERE conditions if they exist\n    const whereMatch = query.match(/WHERE\\s+(.*?)(?:\\s+GROUP BY|\\s+ORDER BY|\\s+LIMIT|$)/i);\n    \n    if (whereMatch && whereMatch[1]) {\n      const conditions = whereMatch[1];\n      console.log(`WHERE conditions for default query: ${conditions}`);\n      \n      // Apply filters\n      if (conditions.includes('company_id =')) {\n        const companyMatch = conditions.match(/company_id\\s*=\\s*'([^']+)'/i);\n        if (companyMatch && companyMatch[1]) {\n          supabaseQuery = supabaseQuery.eq('company_id', companyMatch[1]);\n          console.log(`Applied company filter for default query: company_id = ${companyMatch[1]}`);\n        }\n      }\n    }\n    \n    const { data, error } = await supabaseQuery;\n    \n    if (error) {\n      console.error('Error executing query:', error);\n      console.error('Error details:', JSON.stringify(error, null, 2));\n      return [];\n    }\n    \n    console.log(`Query returned ${data?.length || 0} items`);\n    return data || [];\n  } catch (err) {\n    console.error('Error handling query execution:', err);\n    console.error('Error stack:', err instanceof Error ? err.stack : 'Unknown error');\n    return [];\n  }\n};\n\n/**\n * Get general dashboard stats based on filters\n */\nexport const getGeneralDashboardStats = async (\n  filters: { advisorId?: string; companyId?: string; startDate?: string; endDate?: string }\n): Promise<DashboardStats> => {\n  try {\n    // Filter conditions\n    let filterConditions = '';\n    const conditions: string[] = [];\n    \n    if (filters.advisorId) {\n      conditions.push(`assigned_to = '${filters.advisorId}'`);\n    }\n    \n    if (filters.companyId) {\n      conditions.push(`company_id = '${filters.companyId}'`);\n    }\n    \n    if (filters.startDate) {\n      conditions.push(`created_at >= '${filters.startDate}'`);\n    }\n    \n    if (filters.endDate) {\n      conditions.push(`created_at <= '${filters.endDate}'`);\n    }\n    \n    if (conditions.length > 0) {\n      filterConditions = ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    // Get total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n    `;\n    const totalApplicationsResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalApplicationsResult[0]?.total || '0');\n\n    // Get applications by status\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY status\n    `;\n    const applicationsByStatusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus: Record<string, number> = {};\n    \n    if (applicationsByStatusResult && Array.isArray(applicationsByStatusResult)) {\n      applicationsByStatusResult.forEach((item: any) => {\n        if (!item || !item.status) return;\n        \n        const status = item.status;\n        let count = 0;\n        \n        if (typeof item.count === 'number') {\n          count = item.count;\n        } else if (typeof item.count === 'string') {\n          count = parseInt(item.count, 10) || 0;\n        } else if (item.count) {\n          count = parseInt(String(item.count), 10) || 0;\n        }\n        \n        applicationsByStatus[status] = count;\n      });\n    }\n    \n    // Calcular aplicaciones aprobadas, rechazadas y pendientes\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    const pendingApplications = applicationsByStatus['pending'] || 0;\n    \n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n    `;\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = parseFloat(amountResult[0]?.total_amount || '0');\n    const averageAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n\n    // Get recent applications\n    const recentApplicationsQuery = `\n      SELECT *\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;\n    const recentApplicationsResult = await executeQuery(recentApplicationsQuery);\n    const recentApplications = recentApplicationsResult as Application[];\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY month \n      ORDER BY month\n    `;\n    const applicationsByMonthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = applicationsByMonthResult.map((item: any) => ({\n      month: item.month,\n      count: parseInt(item.count)\n    }));\n\n    // Get advisor performance\n    const advisorPerformanceQuery = `\n        SELECT \n        assigned_to as advisor_id,\n          COUNT(*) as total_applications,\n        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved_applications\n      FROM ${TABLES.APPLICATIONS}${filterConditions}\n      GROUP BY assigned_to\n    `;\n    \n    const advisorPerformanceResult = await executeQuery(advisorPerformanceQuery);\n    const advisorPerformance: AdvisorPerformance[] = advisorPerformanceResult.map((item: any) => {\n      const applications = parseInt(item.total_applications);\n      const approvedApplications = parseInt(item.approved_applications);\n      \n      return {\n        advisorId: item.advisor_id,\n        applications,\n        approvalRate: applications > 0 ? (approvedApplications / applications) * 100 : 0\n      };\n    });\n    \n    return {\n      totalApplications,\n      pendingApplications,\n      approvedApplications,\n      rejectedApplications,\n      totalAmount,\n      averageAmount,\n      recentApplications,\n      applicationsByMonth,\n      applicationsByStatus,\n      advisorPerformance\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Map a raw status string to a normalized dashboard status\n */\nconst mapToDashboardStatus = (raw?: string): string => {\n  if (!raw) return 'pending';\n  \n  const status = raw.toLowerCase();\n  \n  if (status === 'new' || status === 'solicitud' || status === 'pending') {\n    return 'pending';\n  } else if (status === 'in_review') {\n    return 'in_review';\n  } else if (status === 'approved' || status === 'por_dispersar' || status === 'completed') {\n    return 'approved';\n  } else if (status === 'rejected' || status === 'cancelled' || status === 'expired') {\n    return 'rejected';\n  }\n  \n  return 'pending'; // Default fallback\n};\n\n/**\n * Normalize application status to one of the four dashboard categories:\n * pending, in_review, approved, rejected\n */\nconst normalizeApplicationStatus = (status?: string): string => {\n  return mapToDashboardStatus(status);\n};\n\n/**\n * Get stats for a specific advisor\n */\nexport const getAdvisorStats = async (\n  advisorId: string,\n  filters: QueryFilters = {}\n): Promise<ApplicationStats> => {\n  console.log(`Getting advisor stats for advisorId: ${advisorId} with filters:`, filters);\n\n  try {\n    // Get advisor details to construct the name\n    const advisorQuery = `\n      SELECT a.id, a.email, a.name, a.access_code, u.first_name, u.last_name, u.email as user_email\n      FROM ${TABLES.ADVISORS} a\n      LEFT JOIN ${TABLES.USERS} u ON a.email = u.email\n      WHERE a.id = '${advisorId}'\n    `;\n\n    const advisorResult = await executeQuery(advisorQuery);\n    \n    if (!advisorResult || !advisorResult.length || !advisorResult[0]) {\n      console.error(`No advisor found with ID: ${advisorId}`);\n      throw new Error(`No advisor found with ID: ${advisorId}`);\n    }\n\n    const advisor = advisorResult[0];\n    console.log(`Found advisor:`, advisor);\n\n    // Get the applications by status\n    const applicationsByStatusQuery = `\n      SELECT \n        status,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n      GROUP BY status\n    `;\n\n    // Execute the query and get the results\n    const statusResults = await executeQuery(applicationsByStatusQuery);\n    console.log('Status query results:', statusResults);\n\n    // Initialize the applicationsByStatus with default values\n    const applicationsByStatus: { [key: string]: number } = {\n      'pending': 0,\n      'in_review': 0,\n      'approved': 0,\n      'rejected': 0\n    };\n\n    // Map them to the normalized dashboard statuses\n    if (statusResults && Array.isArray(statusResults)) {\n      statusResults.forEach(result => {\n        if (result && typeof result === 'object' && 'status' in result && 'count' in result) {\n          const status = String(result.status || '');\n          const count = typeof result.count === 'number' ? result.count : \n                        (result.count ? Number(result.count) : 0);\n          \n          // Using the normalized status\n          const normalizedStatus = normalizeApplicationStatus(status);\n          \n          // Add to the appropriate status count (defensively)\n          if (normalizedStatus && applicationsByStatus[normalizedStatus] !== undefined) {\n            applicationsByStatus[normalizedStatus] += count;\n          }\n          \n          console.log(`Mapped status ${status} (normalized: ${normalizedStatus}) with count ${count}`);\n        }\n      });\n    }\n    \n    console.log('Final applicationsByStatus:', applicationsByStatus);\n\n    // Calculate total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n    `;\n\n    const totalResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = totalResult && totalResult[0] ? Number(totalResult[0].count || 0) : 0;\n    console.log(`Total applications: ${totalApplications}`);\n\n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n    `;\n\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = amountResult && amountResult[0] ? Number(amountResult[0].total_amount || 0) : 0;\n    const averageAmount = amountResult && amountResult[0] ? Number(amountResult[0].avg_amount || 0) : 0;\n    console.log(`Total amount: ${totalAmount}, Average amount: ${averageAmount}`);\n\n    // Prepare the application by status chart data (array format for charts)\n    const applicationsByStatusChart = Object.entries(applicationsByStatus).map(([status, count]) => ({\n      status,\n      count\n    }));\n    console.log('applicationsByStatusChart array format:', applicationsByStatusChart);\n\n    // Calculate the conversion rate (approved / total)\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    const pendingApplications = (applicationsByStatus['pending'] || 0) + (applicationsByStatus['in_review'] || 0);\n    \n    const conversionRate = totalApplications > 0 ? Number(((approvedApplications / totalApplications) * 100).toFixed(2)) : 0;\n    console.log(`Calculated conversion rate: ${conversionRate}%`);\n\n    // Create the advisor stats object\n    const advisorStats: ApplicationStats = {\n      advisorId,\n      advisorName: advisor.name || `${advisor.first_name || ''} ${advisor.last_name || ''}`.trim() || advisor.email,\n      totalApplications,\n      approvedApplications,\n      rejectedApplications,\n      pendingApplications,\n      totalAmount,\n      averageAmount,\n      conversionRate,\n      applicationsByStatus,\n      applicationsByStatusChart,\n      applicationsByMonth: [],  // Will be populated later if needed\n      recent: [],  // Will be populated later if needed\n      \n      // Add missing required properties from the ApplicationStats interface\n      recentApplications: [], // This will be filled later if needed\n      advisorPerformance: [], // Not applicable for single advisor stats\n      totalApproved: approvedApplications,\n      totalRejected: rejectedApplications,\n      totalPending: pendingApplications,\n      pendingApproval: 0, // This would need to be calculated separately if needed\n      totalClients: 0, // Would need a separate query to get this\n      totalCompanies: 0, // Would need a separate query to get this\n      avgTimeToApproval: 0 // Would need a separate query to calculate this\n    };\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND created_at <= '${filters.endDate}'` : ''}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n\n    const monthResults = await executeQuery(applicationsByMonthQuery);\n    if (monthResults && Array.isArray(monthResults)) {\n      advisorStats.applicationsByMonth = monthResults.map(result => ({\n        month: String(result.month || ''),\n        count: typeof result.count === 'number' ? result.count : Number(result.count || 0)\n      }));\n    }\n    console.log(`Applications by month (${advisorStats.applicationsByMonth.length} entries)`, advisorStats.applicationsByMonth);\n\n    // Get recent applications\n    const recentApplicationsQuery = `\n      SELECT a.*, c.name as company_name\n      FROM ${TABLES.APPLICATIONS} a\n      LEFT JOIN ${TABLES.COMPANIES} c ON a.company_id = c.id\n      WHERE a.assigned_to = '${advisorId}'\n      ${filters.startDate ? `AND a.created_at >= '${filters.startDate}'` : ''}\n      ${filters.endDate ? `AND a.created_at <= '${filters.endDate}'` : ''}\n      ORDER BY a.created_at DESC\n      LIMIT 5\n    `;\n\n    const recentResults = await executeQuery(recentApplicationsQuery);\n    if (recentResults && Array.isArray(recentResults)) {\n      advisorStats.recent = recentResults;\n      advisorStats.recentApplications = recentResults; // Also populate the recentApplications field\n    }\n    console.log(`Recent applications (${advisorStats.recent?.length || 0} entries)`, advisorStats.recent || []);\n\n    return advisorStats;\n  } catch (error) {\n    console.error('Error getting advisor stats:', error);\n    throw error;\n  }\n};\n\n/**\n * Get stats for a specific company\n */\nexport const getCompanyDashboardStats = async (\n  companyId: string,\n  filters: { startDate?: string; endDate?: string }\n): Promise<CompanyStats> => {\n  try {\n    console.log('=====================================================');\n    console.log(`COMPANY DASHBOARD STATS - Company ID: ${companyId}`);\n    console.log('=====================================================');\n    console.log('Filters:', JSON.stringify(filters));\n    \n    // Filter conditions for date range\n    let dateFilterConditions = '';\n    const dateConditions: string[] = [];\n    \n    if (filters.startDate) {\n      dateConditions.push(`created_at >= '${filters.startDate}'`);\n    }\n    \n    if (filters.endDate) {\n      dateConditions.push(`created_at <= '${filters.endDate}'`);\n    }\n    \n    if (dateConditions.length > 0) {\n      dateFilterConditions = ` AND ${dateConditions.join(' AND ')}`;\n    }\n\n    // Base filter for company\n    const baseFilter = `company_id = '${companyId}'${dateFilterConditions}`;\n    console.log(`SQL base filter: ${baseFilter}`);\n\n    // Get total applications\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching total applications...');\n    const totalApplicationsResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalApplicationsResult[0]?.total || '0');\n    console.log(`Total applications: ${totalApplications}`);\n\n    // Get applications by status\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      GROUP BY status\n    `;\n    console.log('Fetching applications by status...');\n    const applicationsByStatusResult = await executeQuery(applicationsByStatusQuery);\n    console.log('Applications by status raw result:', applicationsByStatusResult);\n    \n    // Convert the result to the required format and calculate totals by status\n    const statusMap: Record<string, number> = {};\n    const applicationsByStatus: {status: string; count: number}[] = [];\n    \n    if (applicationsByStatusResult && Array.isArray(applicationsByStatusResult)) {\n      applicationsByStatusResult.forEach((item: any) => {\n        if (!item) return;\n        \n        const status = item.status || 'unknown';\n        let count = 0;\n        \n        if (typeof item.count === 'number') {\n          count = item.count;\n        } else if (typeof item.count === 'string') {\n          count = parseInt(item.count, 10) || 0;\n        } else if (item.count) {\n          count = parseInt(String(item.count), 10) || 0;\n        }\n        \n        // Store in a map for easy access\n        statusMap[status] = count;\n        \n        // Also add to the array format\n        applicationsByStatus.push({ status, count });\n      });\n    }\n    \n    // Get the counts for specific statuses - defaulting to 0 if not found\n    const approvedApplications = statusMap['approved'] || 0;\n    const rejectedApplications = statusMap['rejected'] || 0;\n    const pendingApplications = statusMap['pending'] || 0;\n    \n    console.log('Status totals:', { \n      approved: approvedApplications, \n      rejected: rejectedApplications, \n      pending: pendingApplications\n    });\n\n    // Get total amount and average amount\n    const amountQuery = `\n      SELECT \n        SUM(amount) as total_amount,\n        AVG(amount) as avg_amount\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching amount totals...');\n    const amountResult = await executeQuery(amountQuery);\n    const totalAmount = parseFloat(amountResult[0]?.total_amount || '0');\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    console.log(`Amount totals: total=${totalAmount}, average=${avgAmount}`);\n\n    // Get recent applications with advisor info\n    const recentApplicationsQuery = `\n      SELECT a.*, adv.id as advisor_id, adv.user_id, adv.specialization\n      FROM ${TABLES.APPLICATIONS} a\n      LEFT JOIN ${TABLES.ADVISORS} adv ON a.assigned_to = adv.user_id\n      WHERE a.${baseFilter}\n      ORDER BY a.created_at DESC\n      LIMIT 5\n    `;\n    console.log('Fetching recent applications...');\n    const recentApplicationsResult = await executeQuery(recentApplicationsQuery);\n    console.log(`Retrieved ${recentApplicationsResult.length} recent applications`);\n    \n    // Map the results to include advisor info\n    const recentApplications = recentApplicationsResult.map((app: any) => {\n      // Check if app has advisor-related fields\n      const hasAdvisorInfo = !!app.advisor_id;\n      console.log(`Application ${app.id} has advisor info: ${hasAdvisorInfo}`);\n      \n      return {\n        ...app,\n        advisor: hasAdvisorInfo ? {\n          id: app.advisor_id,\n          user_id: app.user_id,\n          specialization: app.specialization\n        } : null\n      };\n    }) as Application[];\n\n    // Get applications by month\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      GROUP BY month\n      ORDER BY month\n    `;\n    console.log('Fetching applications by month...');\n    const applicationsByMonthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = applicationsByMonthResult.map((item: any) => ({\n      month: item.month || '',\n      count: parseInt(String(item.count), 10) || 0 // Ensure count is always a number\n    }));\n    console.log(`Retrieved ${applicationsByMonth.length} months of application data`);\n\n    // Get total unique clients\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT client_id) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n    `;\n    console.log('Fetching total clients...');\n    const totalClientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(totalClientsResult[0]?.total || '0');\n    console.log(`Total clients: ${totalClients}`);\n\n    // Get total advisors for this company\n    const totalAdvisorsQuery = `\n      SELECT COUNT(*) as total\n      FROM ${TABLES.ADVISORS}\n      WHERE company_id = '${companyId}'\n    `;\n    console.log('Fetching total advisors...');\n    const totalAdvisorsResult = await executeQuery(totalAdvisorsQuery);\n    const totalAdvisors = parseInt(totalAdvisorsResult[0]?.total || '0');\n    console.log(`Total advisors: ${totalAdvisors}`);\n\n    // Calculate average time to approval for company\n    const avgApprovalTimeQuery = `\n      SELECT AVG(\n        EXTRACT(EPOCH FROM (approval_date_company - created_at)) / 3600\n      ) as avg_time\n      FROM ${TABLES.APPLICATIONS} \n      WHERE ${baseFilter}\n      AND approval_date_company IS NOT NULL\n    `;\n    console.log('Fetching average approval time...');\n    const avgApprovalTimeResult = await executeQuery(avgApprovalTimeQuery);\n    const avgApprovalTime = parseFloat(avgApprovalTimeResult[0]?.avg_time || '0');\n    console.log(`Average approval time: ${avgApprovalTime} hours`);\n\n    // Get advisor performance for this company\n    try {\n      const advisorPerformanceQuery = `\n        SELECT \n          a.assigned_to as advisor_id,\n          u.first_name || ' ' || u.last_name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications,\n          SUM(CASE WHEN a.status = 'pending' THEN 1 ELSE 0 END) as pending_applications,\n          AVG(\n            CASE \n              WHEN a.approval_date_advisor IS NOT NULL \n              THEN EXTRACT(EPOCH FROM (a.approval_date_advisor - a.created_at)) / 3600\n              ELSE NULL\n            END\n          ) as avg_approval_time\n        FROM ${TABLES.APPLICATIONS} a\n        JOIN ${TABLES.USERS} u ON a.assigned_to = u.id\n        WHERE a.${baseFilter}\n        GROUP BY a.assigned_to, u.first_name, u.last_name\n      `;\n      \n      console.log('Fetching advisor performance...');\n      const advisorPerformanceResult = await executeQuery(advisorPerformanceQuery);\n      console.log(`Retrieved advisor performance for ${advisorPerformanceResult.length} advisors`);\n      \n      const advisorPerformance: AdvisorPerformanceStats[] = advisorPerformanceResult.map((item: any) => {\n        const totalApplications = parseInt(item.total_applications || '0');\n        const approvedApplications = parseInt(item.approved_applications || '0');\n        const rejectedApplications = parseInt(item.rejected_applications || '0');\n        const pendingApplications = parseInt(item.pending_applications || '0');\n        \n        return {\n          advisorId: item.advisor_id || '',\n          advisorName: item.advisor_name || '',\n          totalApplications,\n          approvedApplications,\n          rejectedApplications,\n          pendingApplications,\n          approvalRate: totalApplications > 0 ? (approvedApplications / totalApplications) * 100 : 0,\n          avgApprovalTime: parseFloat(item.avg_approval_time || '0')\n        };\n      });\n\n      // Build the final result object\n      const result: CompanyStats = {\n        totalApplications,\n        pendingApplications,\n        approvedApplications,\n        rejectedApplications,\n        totalAmount,\n        avgAmount,\n        recentApplications,\n        applicationsByMonth,\n        applicationsByStatus,\n        advisorPerformance,\n        totalClients,\n        totalAdvisors,\n        avgApprovalTime\n      };\n      \n      console.log('Successfully compiled complete company dashboard stats');\n      return result;\n    } catch (error) {\n      console.error('Error in advisor performance section:', error);\n      console.error('Error stack:', error instanceof Error ? error.stack : 'Unknown error');\n      \n      // Return data without advisor performance if there's an error\n      const result: CompanyStats = {\n        totalApplications,\n        pendingApplications,\n        approvedApplications,\n        rejectedApplications,\n        totalAmount,\n        avgAmount,\n        recentApplications,\n        applicationsByMonth,\n        applicationsByStatus,\n        advisorPerformance: [],\n        totalClients,\n      totalAdvisors,\n        avgApprovalTime\n      };\n      \n      console.log('Returning company dashboard stats without advisor performance due to error');\n      return result;\n    }\n  } catch (error) {\n    console.error('Error getting company dashboard stats:', error);\n    console.error('Error stack:', error instanceof Error ? error.stack : 'Unknown error');\n    throw error;\n  }\n};\n\n/**\n * Get pending approvals for user\n */\nexport const getPendingApprovals = async (userId: string, isCompanyAdmin: boolean) => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Aplicaciones pendientes de aprobación por la empresa\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${userId}'\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    const totalPending = parseInt(result[0]?.pending_count || '0');\n\n    // Obtener aplicaciones pendientes de aprobación\n    const pendingApplicationsQuery = `\n      SELECT *\n      FROM ${TABLES.APPLICATIONS}\n      WHERE ${isCompanyAdmin ? 'company_id' : 'assigned_to'} = '${userId}'\n      AND ${isCompanyAdmin ? 'approved_by_company = false' : 'approved_by_advisor = false'}\n    `;\n    const pendingApplicationsResult = await executeQuery(pendingApplicationsQuery);\n    const pendingApplications = pendingApplicationsResult.map((app: any) => ({\n      ...app,\n      approval_date_company: app.approval_date_company ? new Date(app.approval_date_company).toISOString() : null,\n      approval_date_advisor: app.approval_date_advisor ? new Date(app.approval_date_advisor).toISOString() : null\n    }));\n\n    return {\n      totalPending,\n      pendingApplications\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}