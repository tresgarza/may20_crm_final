{"ast":null,"code":"import * as documentService from '../documentService';\nimport { formatApiError, logError } from '../../utils/errorHandling';\n\n/**\n * Result of a document upload operation\n */\n\n/**\n * Creates an empty document upload result\n */\nconst createEmptyUploadResult = () => ({\n  successful: [],\n  failed: [],\n  allSuccessful: true\n});\n\n/**\n * Validates a document array ensuring all documents have required fields\n * @param documents The array of documents to validate\n * @returns An array of valid documents\n */\nexport const validateDocuments = documents => {\n  if (!documents || documents.length === 0) {\n    return [];\n  }\n  return documents.filter(doc => {\n    if (!doc.file || !doc.category || !doc.name) {\n      console.error('Invalid document detected:', JSON.stringify({\n        name: doc.name || 'undefined',\n        category: doc.category || 'undefined',\n        hasFile: !!doc.file\n      }));\n      return false;\n    }\n    return true;\n  });\n};\n\n/**\n * Uploads documents for a client with proper error handling and retries\n * @param clientId The ID of the client\n * @param userId The ID of the user uploading the documents\n * @param documents Array of documents to upload\n * @returns Document upload result with success and failure information\n */\nexport const uploadClientDocuments = async (clientId, userId, documents) => {\n  if (!documents || documents.length === 0) {\n    console.log('No documents to upload');\n    return createEmptyUploadResult();\n  }\n  console.log(`Attempting to upload ${documents.length} documents for client ${clientId}`);\n\n  // Filter out invalid documents\n  const validDocuments = validateDocuments(documents);\n  if (validDocuments.length === 0) {\n    console.warn('No valid documents to upload after filtering');\n    return {\n      successful: [],\n      failed: documents.map(doc => ({\n        name: doc.name || 'Sin nombre',\n        category: doc.category || 'Sin categoría',\n        error: 'Documento inválido: falta el archivo, nombre o categoría'\n      })),\n      allSuccessful: false,\n      warningMessage: 'No se pudo subir ningún documento porque todos estaban incompletos (faltan archivos, nombres o categorías).'\n    };\n  }\n\n  // Process documents sequentially to avoid race conditions\n  const results = [];\n  const failedDocuments = [];\n  try {\n    // Check if storage bucket exists before attempting uploads\n    try {\n      console.log(`Checking if storage bucket \"documents\" exists...`);\n      await documentService.ensureStorageBucketExists();\n      console.log(`Storage bucket \"documents\" exists and is accessible.`);\n    } catch (bucketError) {\n      console.warn('Bucket availability check failed, documents will not be uploaded:', bucketError);\n\n      // Add all documents to failed list but allow client update to proceed\n      return handleBucketCheckFailure(validDocuments, bucketError);\n    }\n\n    // Upload documents one by one\n    for (const doc of validDocuments) {\n      try {\n        const result = await uploadSingleDocument(doc, clientId, userId);\n        if (result.success) {\n          results.push(result.data);\n          console.log(`Successfully uploaded document ${doc.name} (${result.data.id})`);\n        } else {\n          failedDocuments.push({\n            name: doc.name,\n            category: doc.category,\n            error: result.error || 'Error desconocido'\n          });\n        }\n      } catch (docError) {\n        console.error(`Failed to upload document ${doc.name}:`, docError);\n        failedDocuments.push({\n          name: doc.name,\n          category: doc.category,\n          error: docError instanceof Error ? docError.message : 'Error desconocido'\n        });\n      }\n    }\n\n    // Log summary of upload results\n    if (failedDocuments.length > 0) {\n      console.warn(`${failedDocuments.length} documents failed to upload:`, failedDocuments);\n      console.log(`Successful uploads: ${results.length}/${validDocuments.length}`);\n    }\n\n    // Format results with appropriate warning message\n    return formatUploadResults(results, failedDocuments, validDocuments.length);\n  } catch (error) {\n    logError(error, 'uploadClientDocuments');\n    const formattedError = formatApiError(error, 'document-upload');\n    throw new Error(formattedError.message);\n  }\n};\n\n/**\n * Handles the case where bucket check fails\n */\nconst handleBucketCheckFailure = (validDocuments, bucketError) => {\n  const failedDocuments = validDocuments.map(doc => ({\n    name: doc.name,\n    category: doc.category,\n    error: 'El almacenamiento de documentos no está disponible temporalmente'\n  }));\n\n  // Provide better error message\n  let errorDetail = '';\n  if (bucketError instanceof Error) {\n    errorDetail = bucketError.message;\n\n    // Specific messages based on error type\n    if (errorDetail.includes('404') || errorDetail.includes('not found') || errorDetail.includes('no existe')) {\n      errorDetail = 'El bucket \"documents\" no existe en Supabase Storage.';\n    } else if (errorDetail.includes('violates row-level security policy') || errorDetail.includes('Permission denied') || errorDetail.includes('Unauthorized')) {\n      errorDetail = 'No tienes permisos para acceder al bucket \"documents\".';\n    }\n  }\n  return {\n    successful: [],\n    failed: failedDocuments,\n    allSuccessful: false,\n    warningMessage: `Se actualizó la información del cliente, pero no se pudieron subir los documentos: ${errorDetail} El administrador debe verificar las políticas del bucket \"documents\" en Supabase Storage.`\n  };\n};\n\n/**\n * Uploads a single document with retries\n */\nconst uploadSingleDocument = async (doc, clientId, userId) => {\n  console.log(`Attempting to upload document ${doc.name} for client ${clientId}`);\n\n  // Try up to 3 times with exponential backoff\n  for (let attempt = 1; attempt <= 3; attempt++) {\n    try {\n      const result = await documentService.uploadDocument({\n        file: doc.file,\n        client_id: clientId,\n        application_id: undefined,\n        userId,\n        documentName: doc.name,\n        category: doc.category,\n        description: doc.description || undefined\n      });\n      return {\n        success: true,\n        data: result\n      };\n    } catch (uploadError) {\n      console.error(`Error uploading document ${doc.name} (attempt ${attempt}/3):`, uploadError);\n\n      // Check for security policy errors which won't be fixed by retrying\n      if (uploadError instanceof Error && (uploadError.message.includes(\"violates row-level security policy\") || uploadError.message.includes(\"permission denied\") || uploadError.message.includes(\"Unauthorized\") || uploadError.message.includes(\"403\"))) {\n        return {\n          success: false,\n          error: 'Error de permisos: No se pueden subir documentos debido a restricciones de seguridad. Contacte al administrador para configurar las políticas RLS en Supabase.'\n        };\n      }\n\n      // If this was the last attempt, return the error\n      if (attempt === 3) {\n        let errorMessage = 'Error desconocido';\n        if (uploadError instanceof Error) {\n          errorMessage = uploadError.message;\n        }\n        return {\n          success: false,\n          error: errorMessage\n        };\n      }\n\n      // Wait before retry with exponential backoff\n      const waitTime = 1000 * Math.pow(2, attempt - 1);\n      console.log(`Waiting ${waitTime}ms before retrying upload for document ${doc.name}`);\n      await new Promise(r => setTimeout(r, waitTime));\n      console.log(`Retrying upload for document ${doc.name} (attempt ${attempt + 1}/3)`);\n    }\n  }\n\n  // Should never reach here, but TypeScript needs this\n  return {\n    success: false,\n    error: 'Error inesperado durante la carga del documento'\n  };\n};\n\n/**\n * Creates a formatted upload result with appropriate warning message\n */\nconst formatUploadResults = (successful, failed, totalCount) => {\n  let warningMessage = null;\n  if (failed.length > 0) {\n    if (failed.length === totalCount) {\n      // All uploads failed - check for permission issues\n      if (failed.some(doc => doc.error && (doc.error.includes('permisos') || doc.error.includes('seguridad') || doc.error.includes('policy') || doc.error.includes('RLS')))) {\n        warningMessage = 'Se guardó la información del cliente, pero no se pudo subir ningún documento debido a permisos insuficientes. Contacta al administrador para resolver el problema de políticas RLS en Supabase.';\n      } else {\n        warningMessage = 'Se guardó la información del cliente, pero no se pudo subir ningún documento. Por favor, intenta nuevamente más tarde.';\n      }\n    } else {\n      warningMessage = `Se guardó la información del cliente y se subieron ${successful.length} documentos, pero ${failed.length} ${failed.length === 1 ? 'documento falló' : 'documentos fallaron'} al subirse. Puedes intentar subir los documentos fallidos más tarde.`;\n    }\n  }\n  return {\n    successful,\n    failed,\n    allSuccessful: failed.length === 0,\n    warningMessage\n  };\n};","map":{"version":3,"names":["documentService","formatApiError","logError","createEmptyUploadResult","successful","failed","allSuccessful","validateDocuments","documents","length","filter","doc","file","category","name","console","error","JSON","stringify","hasFile","uploadClientDocuments","clientId","userId","log","validDocuments","warn","map","warningMessage","results","failedDocuments","ensureStorageBucketExists","bucketError","handleBucketCheckFailure","result","uploadSingleDocument","success","push","data","id","docError","Error","message","formatUploadResults","formattedError","errorDetail","includes","attempt","uploadDocument","client_id","application_id","undefined","documentName","description","uploadError","errorMessage","waitTime","Math","pow","Promise","r","setTimeout","totalCount","some"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/client/clientDocumentService.ts"],"sourcesContent":["import { ClientDocument } from '../../types/client';\nimport * as documentService from '../documentService';\nimport { formatApiError, logError } from '../../utils/errorHandling';\n\n/**\n * Result of a document upload operation\n */\nexport interface DocumentUploadResult {\n  successful: any[];\n  failed: {\n    name: string;\n    category: string;\n    error: string;\n  }[];\n  allSuccessful: boolean;\n  warningMessage?: string | null;\n}\n\n/**\n * Creates an empty document upload result\n */\nconst createEmptyUploadResult = (): DocumentUploadResult => ({\n  successful: [],\n  failed: [],\n  allSuccessful: true\n});\n\n/**\n * Validates a document array ensuring all documents have required fields\n * @param documents The array of documents to validate\n * @returns An array of valid documents\n */\nexport const validateDocuments = (documents: ClientDocument[]): ClientDocument[] => {\n  if (!documents || documents.length === 0) {\n    return [];\n  }\n\n  return documents.filter(doc => {\n    if (!doc.file || !doc.category || !doc.name) {\n      console.error('Invalid document detected:', JSON.stringify({\n        name: doc.name || 'undefined',\n        category: doc.category || 'undefined',\n        hasFile: !!doc.file\n      }));\n      return false;\n    }\n    return true;\n  });\n};\n\n/**\n * Uploads documents for a client with proper error handling and retries\n * @param clientId The ID of the client\n * @param userId The ID of the user uploading the documents\n * @param documents Array of documents to upload\n * @returns Document upload result with success and failure information\n */\nexport const uploadClientDocuments = async (\n  clientId: string, \n  userId: string, \n  documents: ClientDocument[]\n): Promise<DocumentUploadResult> => {\n  if (!documents || documents.length === 0) {\n    console.log('No documents to upload');\n    return createEmptyUploadResult();\n  }\n\n  console.log(`Attempting to upload ${documents.length} documents for client ${clientId}`);\n  \n  // Filter out invalid documents\n  const validDocuments = validateDocuments(documents);\n\n  if (validDocuments.length === 0) {\n    console.warn('No valid documents to upload after filtering');\n    return {\n      successful: [],\n      failed: documents.map(doc => ({\n        name: doc.name || 'Sin nombre',\n        category: doc.category || 'Sin categoría',\n        error: 'Documento inválido: falta el archivo, nombre o categoría'\n      })),\n      allSuccessful: false,\n      warningMessage: 'No se pudo subir ningún documento porque todos estaban incompletos (faltan archivos, nombres o categorías).'\n    };\n  }\n\n  // Process documents sequentially to avoid race conditions\n  const results = [];\n  const failedDocuments = [];\n  \n  try {\n    // Check if storage bucket exists before attempting uploads\n    try {\n      console.log(`Checking if storage bucket \"documents\" exists...`);\n      await documentService.ensureStorageBucketExists();\n      console.log(`Storage bucket \"documents\" exists and is accessible.`);\n    } catch (bucketError) {\n      console.warn('Bucket availability check failed, documents will not be uploaded:', bucketError);\n      \n      // Add all documents to failed list but allow client update to proceed\n      return handleBucketCheckFailure(validDocuments, bucketError);\n    }\n    \n    // Upload documents one by one\n    for (const doc of validDocuments) {\n      try {\n        const result = await uploadSingleDocument(doc, clientId, userId);\n        if (result.success) {\n          results.push(result.data);\n          console.log(`Successfully uploaded document ${doc.name} (${result.data.id})`);\n        } else {\n          failedDocuments.push({\n            name: doc.name,\n            category: doc.category,\n            error: result.error || 'Error desconocido'\n          });\n        }\n      } catch (docError) {\n        console.error(`Failed to upload document ${doc.name}:`, docError);\n        failedDocuments.push({\n          name: doc.name,\n          category: doc.category,\n          error: docError instanceof Error ? docError.message : 'Error desconocido'\n        });\n      }\n    }\n    \n    // Log summary of upload results\n    if (failedDocuments.length > 0) {\n      console.warn(`${failedDocuments.length} documents failed to upload:`, failedDocuments);\n      console.log(`Successful uploads: ${results.length}/${validDocuments.length}`);\n    }\n    \n    // Format results with appropriate warning message\n    return formatUploadResults(results, failedDocuments, validDocuments.length);\n    \n  } catch (error) {\n    logError(error, 'uploadClientDocuments');\n    \n    const formattedError = formatApiError(error, 'document-upload');\n    throw new Error(formattedError.message);\n  }\n};\n\n/**\n * Handles the case where bucket check fails\n */\nconst handleBucketCheckFailure = (\n  validDocuments: ClientDocument[], \n  bucketError: any\n): DocumentUploadResult => {\n  const failedDocuments = validDocuments.map(doc => ({\n    name: doc.name,\n    category: doc.category,\n    error: 'El almacenamiento de documentos no está disponible temporalmente'\n  }));\n  \n  // Provide better error message\n  let errorDetail = '';\n  if (bucketError instanceof Error) {\n    errorDetail = bucketError.message;\n    \n    // Specific messages based on error type\n    if (errorDetail.includes('404') || errorDetail.includes('not found') || errorDetail.includes('no existe')) {\n      errorDetail = 'El bucket \"documents\" no existe en Supabase Storage.';\n    } else if (errorDetail.includes('violates row-level security policy') || \n              errorDetail.includes('Permission denied') || \n              errorDetail.includes('Unauthorized')) {\n      errorDetail = 'No tienes permisos para acceder al bucket \"documents\".';\n    }\n  }\n  \n  return {\n    successful: [],\n    failed: failedDocuments,\n    allSuccessful: false,\n    warningMessage: `Se actualizó la información del cliente, pero no se pudieron subir los documentos: ${errorDetail} El administrador debe verificar las políticas del bucket \"documents\" en Supabase Storage.`\n  };\n};\n\n/**\n * Uploads a single document with retries\n */\nconst uploadSingleDocument = async (\n  doc: ClientDocument, \n  clientId: string, \n  userId: string\n): Promise<{success: boolean, data?: any, error?: string}> => {\n  console.log(`Attempting to upload document ${doc.name} for client ${clientId}`);\n  \n  // Try up to 3 times with exponential backoff\n  for (let attempt = 1; attempt <= 3; attempt++) {\n    try {\n      const result = await documentService.uploadDocument({\n        file: doc.file,\n        client_id: clientId,\n        application_id: undefined,\n        userId,\n        documentName: doc.name,\n        category: doc.category,\n        description: doc.description || undefined\n      });\n      \n      return { \n        success: true, \n        data: result \n      };\n    } catch (uploadError) {\n      console.error(`Error uploading document ${doc.name} (attempt ${attempt}/3):`, uploadError);\n      \n      // Check for security policy errors which won't be fixed by retrying\n      if (uploadError instanceof Error && \n          (uploadError.message.includes(\"violates row-level security policy\") || \n           uploadError.message.includes(\"permission denied\") || \n           uploadError.message.includes(\"Unauthorized\") ||\n           uploadError.message.includes(\"403\"))) {\n        \n        return {\n          success: false,\n          error: 'Error de permisos: No se pueden subir documentos debido a restricciones de seguridad. Contacte al administrador para configurar las políticas RLS en Supabase.'\n        };\n      }\n      \n      // If this was the last attempt, return the error\n      if (attempt === 3) {\n        let errorMessage = 'Error desconocido';\n        if (uploadError instanceof Error) {\n          errorMessage = uploadError.message;\n        }\n        \n        return {\n          success: false,\n          error: errorMessage\n        };\n      }\n      \n      // Wait before retry with exponential backoff\n      const waitTime = 1000 * Math.pow(2, attempt - 1);\n      console.log(`Waiting ${waitTime}ms before retrying upload for document ${doc.name}`);\n      await new Promise(r => setTimeout(r, waitTime));\n      console.log(`Retrying upload for document ${doc.name} (attempt ${attempt + 1}/3)`);\n    }\n  }\n  \n  // Should never reach here, but TypeScript needs this\n  return {\n    success: false,\n    error: 'Error inesperado durante la carga del documento'\n  };\n};\n\n/**\n * Creates a formatted upload result with appropriate warning message\n */\nconst formatUploadResults = (\n  successful: any[], \n  failed: {name: string, category: string, error: string}[],\n  totalCount: number\n): DocumentUploadResult => {\n  let warningMessage = null;\n  \n  if (failed.length > 0) {\n    if (failed.length === totalCount) {\n      // All uploads failed - check for permission issues\n      if (failed.some(doc => doc.error && (\n        doc.error.includes('permisos') || \n        doc.error.includes('seguridad') || \n        doc.error.includes('policy') || \n        doc.error.includes('RLS')))) {\n        warningMessage = 'Se guardó la información del cliente, pero no se pudo subir ningún documento debido a permisos insuficientes. Contacta al administrador para resolver el problema de políticas RLS en Supabase.';\n      } else {\n        warningMessage = 'Se guardó la información del cliente, pero no se pudo subir ningún documento. Por favor, intenta nuevamente más tarde.';\n      }\n    } else {\n      warningMessage = `Se guardó la información del cliente y se subieron ${successful.length} documentos, pero ${failed.length} ${failed.length === 1 ? 'documento falló' : 'documentos fallaron'} al subirse. Puedes intentar subir los documentos fallidos más tarde.`;\n    }\n  }\n  \n  return {\n    successful,\n    failed,\n    allSuccessful: failed.length === 0,\n    warningMessage\n  };\n}; "],"mappings":"AACA,OAAO,KAAKA,eAAe,MAAM,oBAAoB;AACrD,SAASC,cAAc,EAAEC,QAAQ,QAAQ,2BAA2B;;AAEpE;AACA;AACA;;AAYA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAGA,CAAA,MAA6B;EAC3DC,UAAU,EAAE,EAAE;EACdC,MAAM,EAAE,EAAE;EACVC,aAAa,EAAE;AACjB,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAIC,SAA2B,IAAuB;EAClF,IAAI,CAACA,SAAS,IAAIA,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;IACxC,OAAO,EAAE;EACX;EAEA,OAAOD,SAAS,CAACE,MAAM,CAACC,GAAG,IAAI;IAC7B,IAAI,CAACA,GAAG,CAACC,IAAI,IAAI,CAACD,GAAG,CAACE,QAAQ,IAAI,CAACF,GAAG,CAACG,IAAI,EAAE;MAC3CC,OAAO,CAACC,KAAK,CAAC,4BAA4B,EAAEC,IAAI,CAACC,SAAS,CAAC;QACzDJ,IAAI,EAAEH,GAAG,CAACG,IAAI,IAAI,WAAW;QAC7BD,QAAQ,EAAEF,GAAG,CAACE,QAAQ,IAAI,WAAW;QACrCM,OAAO,EAAE,CAAC,CAACR,GAAG,CAACC;MACjB,CAAC,CAAC,CAAC;MACH,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,qBAAqB,GAAG,MAAAA,CACnCC,QAAgB,EAChBC,MAAc,EACdd,SAA2B,KACO;EAClC,IAAI,CAACA,SAAS,IAAIA,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;IACxCM,OAAO,CAACQ,GAAG,CAAC,wBAAwB,CAAC;IACrC,OAAOpB,uBAAuB,CAAC,CAAC;EAClC;EAEAY,OAAO,CAACQ,GAAG,CAAC,wBAAwBf,SAAS,CAACC,MAAM,yBAAyBY,QAAQ,EAAE,CAAC;;EAExF;EACA,MAAMG,cAAc,GAAGjB,iBAAiB,CAACC,SAAS,CAAC;EAEnD,IAAIgB,cAAc,CAACf,MAAM,KAAK,CAAC,EAAE;IAC/BM,OAAO,CAACU,IAAI,CAAC,8CAA8C,CAAC;IAC5D,OAAO;MACLrB,UAAU,EAAE,EAAE;MACdC,MAAM,EAAEG,SAAS,CAACkB,GAAG,CAACf,GAAG,KAAK;QAC5BG,IAAI,EAAEH,GAAG,CAACG,IAAI,IAAI,YAAY;QAC9BD,QAAQ,EAAEF,GAAG,CAACE,QAAQ,IAAI,eAAe;QACzCG,KAAK,EAAE;MACT,CAAC,CAAC,CAAC;MACHV,aAAa,EAAE,KAAK;MACpBqB,cAAc,EAAE;IAClB,CAAC;EACH;;EAEA;EACA,MAAMC,OAAO,GAAG,EAAE;EAClB,MAAMC,eAAe,GAAG,EAAE;EAE1B,IAAI;IACF;IACA,IAAI;MACFd,OAAO,CAACQ,GAAG,CAAC,kDAAkD,CAAC;MAC/D,MAAMvB,eAAe,CAAC8B,yBAAyB,CAAC,CAAC;MACjDf,OAAO,CAACQ,GAAG,CAAC,sDAAsD,CAAC;IACrE,CAAC,CAAC,OAAOQ,WAAW,EAAE;MACpBhB,OAAO,CAACU,IAAI,CAAC,mEAAmE,EAAEM,WAAW,CAAC;;MAE9F;MACA,OAAOC,wBAAwB,CAACR,cAAc,EAAEO,WAAW,CAAC;IAC9D;;IAEA;IACA,KAAK,MAAMpB,GAAG,IAAIa,cAAc,EAAE;MAChC,IAAI;QACF,MAAMS,MAAM,GAAG,MAAMC,oBAAoB,CAACvB,GAAG,EAAEU,QAAQ,EAAEC,MAAM,CAAC;QAChE,IAAIW,MAAM,CAACE,OAAO,EAAE;UAClBP,OAAO,CAACQ,IAAI,CAACH,MAAM,CAACI,IAAI,CAAC;UACzBtB,OAAO,CAACQ,GAAG,CAAC,kCAAkCZ,GAAG,CAACG,IAAI,KAAKmB,MAAM,CAACI,IAAI,CAACC,EAAE,GAAG,CAAC;QAC/E,CAAC,MAAM;UACLT,eAAe,CAACO,IAAI,CAAC;YACnBtB,IAAI,EAAEH,GAAG,CAACG,IAAI;YACdD,QAAQ,EAAEF,GAAG,CAACE,QAAQ;YACtBG,KAAK,EAAEiB,MAAM,CAACjB,KAAK,IAAI;UACzB,CAAC,CAAC;QACJ;MACF,CAAC,CAAC,OAAOuB,QAAQ,EAAE;QACjBxB,OAAO,CAACC,KAAK,CAAC,6BAA6BL,GAAG,CAACG,IAAI,GAAG,EAAEyB,QAAQ,CAAC;QACjEV,eAAe,CAACO,IAAI,CAAC;UACnBtB,IAAI,EAAEH,GAAG,CAACG,IAAI;UACdD,QAAQ,EAAEF,GAAG,CAACE,QAAQ;UACtBG,KAAK,EAAEuB,QAAQ,YAAYC,KAAK,GAAGD,QAAQ,CAACE,OAAO,GAAG;QACxD,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,IAAIZ,eAAe,CAACpB,MAAM,GAAG,CAAC,EAAE;MAC9BM,OAAO,CAACU,IAAI,CAAC,GAAGI,eAAe,CAACpB,MAAM,8BAA8B,EAAEoB,eAAe,CAAC;MACtFd,OAAO,CAACQ,GAAG,CAAC,uBAAuBK,OAAO,CAACnB,MAAM,IAAIe,cAAc,CAACf,MAAM,EAAE,CAAC;IAC/E;;IAEA;IACA,OAAOiC,mBAAmB,CAACd,OAAO,EAAEC,eAAe,EAAEL,cAAc,CAACf,MAAM,CAAC;EAE7E,CAAC,CAAC,OAAOO,KAAK,EAAE;IACdd,QAAQ,CAACc,KAAK,EAAE,uBAAuB,CAAC;IAExC,MAAM2B,cAAc,GAAG1C,cAAc,CAACe,KAAK,EAAE,iBAAiB,CAAC;IAC/D,MAAM,IAAIwB,KAAK,CAACG,cAAc,CAACF,OAAO,CAAC;EACzC;AACF,CAAC;;AAED;AACA;AACA;AACA,MAAMT,wBAAwB,GAAGA,CAC/BR,cAAgC,EAChCO,WAAgB,KACS;EACzB,MAAMF,eAAe,GAAGL,cAAc,CAACE,GAAG,CAACf,GAAG,KAAK;IACjDG,IAAI,EAAEH,GAAG,CAACG,IAAI;IACdD,QAAQ,EAAEF,GAAG,CAACE,QAAQ;IACtBG,KAAK,EAAE;EACT,CAAC,CAAC,CAAC;;EAEH;EACA,IAAI4B,WAAW,GAAG,EAAE;EACpB,IAAIb,WAAW,YAAYS,KAAK,EAAE;IAChCI,WAAW,GAAGb,WAAW,CAACU,OAAO;;IAEjC;IACA,IAAIG,WAAW,CAACC,QAAQ,CAAC,KAAK,CAAC,IAAID,WAAW,CAACC,QAAQ,CAAC,WAAW,CAAC,IAAID,WAAW,CAACC,QAAQ,CAAC,WAAW,CAAC,EAAE;MACzGD,WAAW,GAAG,sDAAsD;IACtE,CAAC,MAAM,IAAIA,WAAW,CAACC,QAAQ,CAAC,oCAAoC,CAAC,IAC3DD,WAAW,CAACC,QAAQ,CAAC,mBAAmB,CAAC,IACzCD,WAAW,CAACC,QAAQ,CAAC,cAAc,CAAC,EAAE;MAC9CD,WAAW,GAAG,wDAAwD;IACxE;EACF;EAEA,OAAO;IACLxC,UAAU,EAAE,EAAE;IACdC,MAAM,EAAEwB,eAAe;IACvBvB,aAAa,EAAE,KAAK;IACpBqB,cAAc,EAAE,sFAAsFiB,WAAW;EACnH,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,MAAMV,oBAAoB,GAAG,MAAAA,CAC3BvB,GAAmB,EACnBU,QAAgB,EAChBC,MAAc,KAC8C;EAC5DP,OAAO,CAACQ,GAAG,CAAC,iCAAiCZ,GAAG,CAACG,IAAI,eAAeO,QAAQ,EAAE,CAAC;;EAE/E;EACA,KAAK,IAAIyB,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAI,CAAC,EAAEA,OAAO,EAAE,EAAE;IAC7C,IAAI;MACF,MAAMb,MAAM,GAAG,MAAMjC,eAAe,CAAC+C,cAAc,CAAC;QAClDnC,IAAI,EAAED,GAAG,CAACC,IAAI;QACdoC,SAAS,EAAE3B,QAAQ;QACnB4B,cAAc,EAAEC,SAAS;QACzB5B,MAAM;QACN6B,YAAY,EAAExC,GAAG,CAACG,IAAI;QACtBD,QAAQ,EAAEF,GAAG,CAACE,QAAQ;QACtBuC,WAAW,EAAEzC,GAAG,CAACyC,WAAW,IAAIF;MAClC,CAAC,CAAC;MAEF,OAAO;QACLf,OAAO,EAAE,IAAI;QACbE,IAAI,EAAEJ;MACR,CAAC;IACH,CAAC,CAAC,OAAOoB,WAAW,EAAE;MACpBtC,OAAO,CAACC,KAAK,CAAC,4BAA4BL,GAAG,CAACG,IAAI,aAAagC,OAAO,MAAM,EAAEO,WAAW,CAAC;;MAE1F;MACA,IAAIA,WAAW,YAAYb,KAAK,KAC3Ba,WAAW,CAACZ,OAAO,CAACI,QAAQ,CAAC,oCAAoC,CAAC,IAClEQ,WAAW,CAACZ,OAAO,CAACI,QAAQ,CAAC,mBAAmB,CAAC,IACjDQ,WAAW,CAACZ,OAAO,CAACI,QAAQ,CAAC,cAAc,CAAC,IAC5CQ,WAAW,CAACZ,OAAO,CAACI,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QAEzC,OAAO;UACLV,OAAO,EAAE,KAAK;UACdnB,KAAK,EAAE;QACT,CAAC;MACH;;MAEA;MACA,IAAI8B,OAAO,KAAK,CAAC,EAAE;QACjB,IAAIQ,YAAY,GAAG,mBAAmB;QACtC,IAAID,WAAW,YAAYb,KAAK,EAAE;UAChCc,YAAY,GAAGD,WAAW,CAACZ,OAAO;QACpC;QAEA,OAAO;UACLN,OAAO,EAAE,KAAK;UACdnB,KAAK,EAAEsC;QACT,CAAC;MACH;;MAEA;MACA,MAAMC,QAAQ,GAAG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEX,OAAO,GAAG,CAAC,CAAC;MAChD/B,OAAO,CAACQ,GAAG,CAAC,WAAWgC,QAAQ,0CAA0C5C,GAAG,CAACG,IAAI,EAAE,CAAC;MACpF,MAAM,IAAI4C,OAAO,CAACC,CAAC,IAAIC,UAAU,CAACD,CAAC,EAAEJ,QAAQ,CAAC,CAAC;MAC/CxC,OAAO,CAACQ,GAAG,CAAC,gCAAgCZ,GAAG,CAACG,IAAI,aAAagC,OAAO,GAAG,CAAC,KAAK,CAAC;IACpF;EACF;;EAEA;EACA,OAAO;IACLX,OAAO,EAAE,KAAK;IACdnB,KAAK,EAAE;EACT,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,MAAM0B,mBAAmB,GAAGA,CAC1BtC,UAAiB,EACjBC,MAAyD,EACzDwD,UAAkB,KACO;EACzB,IAAIlC,cAAc,GAAG,IAAI;EAEzB,IAAItB,MAAM,CAACI,MAAM,GAAG,CAAC,EAAE;IACrB,IAAIJ,MAAM,CAACI,MAAM,KAAKoD,UAAU,EAAE;MAChC;MACA,IAAIxD,MAAM,CAACyD,IAAI,CAACnD,GAAG,IAAIA,GAAG,CAACK,KAAK,KAC9BL,GAAG,CAACK,KAAK,CAAC6B,QAAQ,CAAC,UAAU,CAAC,IAC9BlC,GAAG,CAACK,KAAK,CAAC6B,QAAQ,CAAC,WAAW,CAAC,IAC/BlC,GAAG,CAACK,KAAK,CAAC6B,QAAQ,CAAC,QAAQ,CAAC,IAC5BlC,GAAG,CAACK,KAAK,CAAC6B,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QAC7BlB,cAAc,GAAG,iMAAiM;MACpN,CAAC,MAAM;QACLA,cAAc,GAAG,wHAAwH;MAC3I;IACF,CAAC,MAAM;MACLA,cAAc,GAAG,sDAAsDvB,UAAU,CAACK,MAAM,qBAAqBJ,MAAM,CAACI,MAAM,IAAIJ,MAAM,CAACI,MAAM,KAAK,CAAC,GAAG,iBAAiB,GAAG,qBAAqB,uEAAuE;IACtQ;EACF;EAEA,OAAO;IACLL,UAAU;IACVC,MAAM;IACNC,aAAa,EAAED,MAAM,CAACI,MAAM,KAAK,CAAC;IAClCkB;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}