{"ast":null,"code":"import { supabase } from '../services/supabaseService';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\n// Nombre del bucket por defecto para documentos\nconst DEFAULT_BUCKET_NAME = 'client-documents';\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = file => {\n  // Allowed MIME types\n  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/heic', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (document, folder, attempt = 1) => {\n  const file = document.file;\n  if (!isValidDocument(file)) {\n    throw createAppError(ErrorType.VALIDATION, 'Invalid document format or size', {\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size\n    });\n  }\n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n\n    // Upload the file\n    const {\n      error: uploadError\n    } = await supabase.storage.from(DEFAULT_BUCKET_NAME).upload(filePath, file);\n    if (uploadError) {\n      throw createAppError(ErrorType.UPLOAD, `Error uploading document: ${uploadError.message}`, {\n        filePath,\n        attempt\n      }, uploadError);\n    }\n\n    // Get public URL for the uploaded file\n    const {\n      data: publicUrlData\n    } = supabase.storage.from(DEFAULT_BUCKET_NAME).getPublicUrl(filePath);\n\n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', {\n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n\n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n\n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (documents, folder) => {\n  const uploadedDocs = [];\n  const failedDocs = [];\n\n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(uploadDocumentToStorage(document, folder), 'uploadDocuments');\n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({\n        document,\n        error\n      });\n    }\n  }\n  return {\n    uploadedDocs,\n    failedDocs\n  };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName = DEFAULT_BUCKET_NAME) => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n\n    // La API de Supabase v2 no tiene listBuckets() directamente accesible,\n    // por lo que simplemente intentaremos usar el bucket directamente\n    const {\n      data,\n      error\n    } = await supabase.storage.from(bucketName).list('', {\n      limit: 1\n    });\n    if (!error) {\n      console.log(`El bucket ${bucketName} existe y es accesible.`);\n      return true;\n    }\n    console.warn(`No se pudo confirmar si el bucket ${bucketName} existe: ${error.message}`);\n\n    // En vez de crear un bucket (que requiere permisos elevados),\n    // simplemente verificamos si podemos escribir en él\n    try {\n      // Intentar escribir un archivo de prueba para verificar permisos de escritura\n      const testContent = new Blob(['test'], {\n        type: 'text/plain'\n      });\n      const testFilePath = `_test_${Date.now()}.txt`;\n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} para verificar acceso...`);\n      const {\n        error: uploadError\n      } = await supabase.storage.from(bucketName).upload(testFilePath, testContent);\n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await supabase.storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n      throw uploadError;\n    } catch (testError) {\n      console.error(`No se pudo acceder al bucket ${bucketName}:`, testError);\n      throw createAppError(ErrorType.UPLOAD, `No se pudo acceder al bucket de almacenamiento: ${testError.message}`, {\n        bucketName\n      });\n    }\n  } catch (error) {\n    console.error(`Error al verificar el bucket ${bucketName}:`, error);\n    throw createAppError(ErrorType.UPLOAD, `Error al acceder al almacenamiento: ${error.message}`, {\n      bucketName\n    });\n  }\n};\n\n/**\n * Uploads client documents associating them with a client record\n */\nexport const uploadClientDocuments = async (clientId, documents, maxRetries = 2) => {\n  // Ensure the storage bucket exists\n  await ensureClientBucketExists();\n  const folder = `clients/${clientId}`;\n  const processedDocs = [];\n\n  // Process each document\n  for (const doc of documents) {\n    let attempt = 0;\n    let success = false;\n    let fileUrl = '';\n    let lastError = null;\n    while (attempt < maxRetries && !success) {\n      try {\n        attempt++;\n        if (!doc.file) {\n          console.warn(`Skipping document without file: ${doc.docType}`);\n          continue;\n        }\n\n        // Generate unique filename\n        const fileId = uuidv4();\n        const fileExtension = doc.file.name.split('.').pop() || '';\n        const fileName = `${fileId}.${fileExtension}`;\n        const filePath = `${folder}/${fileName}`;\n        console.log(`Uploading ${doc.docType} document: ${filePath} (attempt ${attempt}/${maxRetries})`);\n\n        // Upload the file\n        const {\n          error\n        } = await supabase.storage.from(DEFAULT_BUCKET_NAME).upload(filePath, doc.file, {\n          cacheControl: '3600',\n          upsert: true // Cambiar a true para sobrescribir si existe\n        });\n        if (error) throw error;\n\n        // Get the public URL\n        const {\n          data: urlData\n        } = supabase.storage.from(DEFAULT_BUCKET_NAME).getPublicUrl(filePath);\n        fileUrl = urlData.publicUrl;\n        success = true;\n      } catch (error) {\n        lastError = error;\n        console.error(`Error uploading document (attempt ${attempt}/${maxRetries}):`, error);\n\n        // Wait before retrying (exponential backoff)\n        if (attempt < maxRetries) {\n          const delay = Math.pow(2, attempt) * 500;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    if (success) {\n      // Add successfully uploaded doc to the processed list\n      processedDocs.push({\n        ...doc,\n        url: fileUrl,\n        file: undefined // TypeScript hack to omit 'file' from the result\n      });\n    } else {\n      // Log failure for this document\n      logError(lastError, 'uploadClientDocuments', {\n        clientId,\n        docType: doc.docType,\n        attempts: maxRetries\n      });\n    }\n  }\n  return processedDocs;\n};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","DEFAULT_BUCKET_NAME","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","ensureClientBucketExists","bucketName","console","log","list","limit","warn","testContent","Blob","testFilePath","now","remove","testError","uploadClientDocuments","clientId","maxRetries","processedDocs","doc","success","fileUrl","lastError","docType","cacheControl","upsert","urlData","undefined","attempts"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../services/supabaseService';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { ClientDocument } from '../types/client';\n\n// Nombre del bucket por defecto para documentos\nconst DEFAULT_BUCKET_NAME = 'client-documents';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from(DEFAULT_BUCKET_NAME)\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from(DEFAULT_BUCKET_NAME)\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName: string = DEFAULT_BUCKET_NAME): Promise<boolean> => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    \n    // La API de Supabase v2 no tiene listBuckets() directamente accesible,\n    // por lo que simplemente intentaremos usar el bucket directamente\n    const { data, error } = await supabase.storage\n      .from(bucketName)\n      .list('', { limit: 1 });\n      \n    if (!error) {\n      console.log(`El bucket ${bucketName} existe y es accesible.`);\n      return true;\n    }\n    \n    console.warn(`No se pudo confirmar si el bucket ${bucketName} existe: ${error.message}`);\n    \n    // En vez de crear un bucket (que requiere permisos elevados),\n    // simplemente verificamos si podemos escribir en él\n    try {\n      // Intentar escribir un archivo de prueba para verificar permisos de escritura\n      const testContent = new Blob(['test'], { type: 'text/plain' });\n      const testFilePath = `_test_${Date.now()}.txt`;\n      \n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} para verificar acceso...`);\n      const { error: uploadError } = await supabase.storage\n        .from(bucketName)\n        .upload(testFilePath, testContent);\n      \n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await supabase.storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n      \n      throw uploadError;\n    } catch (testError) {\n      console.error(`No se pudo acceder al bucket ${bucketName}:`, testError);\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `No se pudo acceder al bucket de almacenamiento: ${(testError as Error).message}`,\n        { bucketName }\n      );\n    }\n  } catch (error) {\n    console.error(`Error al verificar el bucket ${bucketName}:`, error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      `Error al acceder al almacenamiento: ${(error as Error).message}`,\n      { bucketName }\n    );\n  }\n};\n\n/**\n * Uploads client documents associating them with a client record\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Ensure the storage bucket exists\n  await ensureClientBucketExists();\n  \n  const folder = `clients/${clientId}`;\n  const processedDocs: Omit<ClientDocument & { url: string }, 'file'>[] = [];\n  \n  // Process each document\n  for (const doc of documents) {\n    let attempt = 0;\n    let success = false;\n    let fileUrl = '';\n    let lastError: any = null;\n    \n    while (attempt < maxRetries && !success) {\n      try {\n        attempt++;\n        \n        if (!doc.file) {\n          console.warn(`Skipping document without file: ${doc.docType}`);\n          continue;\n        }\n        \n        // Generate unique filename\n        const fileId = uuidv4();\n        const fileExtension = doc.file.name.split('.').pop() || '';\n        const fileName = `${fileId}.${fileExtension}`;\n        const filePath = `${folder}/${fileName}`;\n        \n        console.log(`Uploading ${doc.docType} document: ${filePath} (attempt ${attempt}/${maxRetries})`);\n        \n        // Upload the file\n        const { error } = await supabase.storage\n          .from(DEFAULT_BUCKET_NAME)\n          .upload(filePath, doc.file, {\n            cacheControl: '3600',\n            upsert: true // Cambiar a true para sobrescribir si existe\n          });\n        \n        if (error) throw error;\n        \n        // Get the public URL\n        const { data: urlData } = supabase.storage\n          .from(DEFAULT_BUCKET_NAME)\n          .getPublicUrl(filePath);\n\n        fileUrl = urlData.publicUrl;\n        success = true;\n      } catch (error) {\n        lastError = error;\n        console.error(`Error uploading document (attempt ${attempt}/${maxRetries}):`, error);\n        \n        // Wait before retrying (exponential backoff)\n        if (attempt < maxRetries) {\n          const delay = Math.pow(2, attempt) * 500;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    \n    if (success) {\n      // Add successfully uploaded doc to the processed list\n      processedDocs.push({\n        ...doc,\n        url: fileUrl,\n        file: undefined as any // TypeScript hack to omit 'file' from the result\n      });\n    } else {\n      // Log failure for this document\n      logError(lastError, 'uploadClientDocuments', {\n        clientId,\n        docType: doc.docType,\n        attempts: maxRetries\n      });\n    }\n  }\n  \n  return processedDocs;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}