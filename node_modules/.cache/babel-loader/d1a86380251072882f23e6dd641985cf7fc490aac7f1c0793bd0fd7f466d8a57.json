{"ast":null,"code":"import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { ErrorType, createAppError, logError } from '../utils/errorHandling';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'client-documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  try {\n    // First check if the documents table exists\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      console.warn(`Documents table ${DOCUMENTS_TABLE} does not exist.`);\n      return [];\n    }\n    const {\n      data,\n      error\n    } = await supabase.from(DOCUMENTS_TABLE).select('id, created_at, file_name, file_path, file_type, file_size, category, application_id, client_id, uploaded_by_user_id').eq('client_id', clientId).order('created_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error(`Error fetching documents for client ${clientId}:`, error);\n      throw error;\n    }\n    console.log(`Retrieved ${(data === null || data === void 0 ? void 0 : data.length) || 0} documents for client ${clientId}`);\n    return data || [];\n  } catch (error) {\n    console.error(`Error in getClientDocuments for client ${clientId}:`, error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}) => {\n  const supabaseClient = getServiceClient();\n  try {\n    var _uploadError, _uploadError2;\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(`La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`, 'documentService.uploadDocument', {\n        table: DOCUMENTS_TABLE\n      });\n      throw createAppError(ErrorType.DATABASE, `Error de configuración: La tabla de documentos no está correctamente configurada.`, {\n        table: DOCUMENTS_TABLE\n      });\n    }\n\n    // Verificar si el bucket de storage existe\n    const {\n      data: buckets\n    } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === STORAGE_BUCKET);\n    if (!bucketExists) {\n      logError(`El bucket ${STORAGE_BUCKET} no existe.`, 'documentService.uploadDocument', {\n        bucket: STORAGE_BUCKET\n      });\n      throw createAppError(ErrorType.UPLOAD, `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`, {\n        bucket: STORAGE_BUCKET\n      });\n    }\n\n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n\n    // Crear registro del documento\n    const {\n      data,\n      error\n    } = await supabaseClient.from(DOCUMENTS_TABLE).insert({\n      file_name: fileName,\n      file_type: fileType,\n      file_size: fileSize,\n      category,\n      application_id,\n      client_id,\n      uploaded_by_user_id: userId,\n      is_verified: false\n    }).select('*').single();\n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(`Violación de política RLS al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n          error\n        });\n        throw createAppError(ErrorType.AUTHORIZATION, 'No tienes permisos para crear documentos para este cliente o aplicación', {\n          error: error.message\n        });\n      }\n      logError(`Error al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n        error\n      });\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos', {\n        error: error.message\n      });\n    }\n    if (!data) {\n      logError('No se retornaron datos al crear documento', 'documentService.uploadDocument');\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos');\n    }\n    const documentId = data.id;\n\n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n\n    // Intentar subir el archivo con reintentos\n    let uploadError = null;\n    const maxRetries = 3;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const {\n          error: uploadError\n        } = await supabaseClient.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          upsert: true,\n          cacheControl: '3600'\n        });\n        if (uploadError) {\n          throw uploadError;\n        }\n\n        // Obtener URL pública del archivo\n        const {\n          data: publicUrlData\n        } = supabaseClient.storage.from(STORAGE_BUCKET).getPublicUrl(filePath);\n\n        // Actualizar el documento con la ruta del archivo\n        const {\n          error: updateError\n        } = await supabaseClient.from(DOCUMENTS_TABLE).update({\n          file_path: filePath\n        }).eq('id', documentId);\n        if (updateError) {\n          logError(`Error al actualizar ruta del documento: ${updateError.message}`, 'documentService.uploadDocument', {\n            error: updateError\n          });\n        }\n\n        // Construir y devolver el documento\n        const documentResult = {\n          id: documentId,\n          application_id: application_id || undefined,\n          client_id: client_id || undefined,\n          file_name: fileName,\n          file_path: filePath,\n          file_type: fileType,\n          file_size: fileSize,\n          category,\n          uploaded_by_user_id: userId,\n          is_verified: false,\n          created_at: data.created_at\n        };\n        return documentResult;\n      } catch (error) {\n        uploadError = error;\n\n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    logError(`Error al subir documento después de ${maxRetries} intentos: ${((_uploadError = uploadError) === null || _uploadError === void 0 ? void 0 : _uploadError.message) || 'Error desconocido'}`, 'documentService.uploadDocument', {\n      error: uploadError,\n      attempts: maxRetries\n    });\n\n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    throw createAppError(ErrorType.UPLOAD, 'Error al subir el archivo al sistema', {\n      error: (_uploadError2 = uploadError) === null || _uploadError2 === void 0 ? void 0 : _uploadError2.message\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && error.isAppError) {\n      throw error;\n    }\n    logError(`Error inesperado en uploadDocument: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'documentService.uploadDocument', {\n      error\n    });\n    throw createAppError(ErrorType.UNKNOWN, 'Error inesperado al subir documento', {\n      error: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","getServiceClient","TABLES","checkTableExists","ErrorType","createAppError","logError","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","tableExists","warn","length","getDocumentById","id","single","uploadDocument","application_id","client_id","file","category","userId","_uploadError","_uploadError2","table","DATABASE","buckets","listBuckets","bucketExists","some","bucket","name","UPLOAD","fileName","fileType","type","fileSize","size","insert","file_name","file_type","file_size","uploaded_by_user_id","is_verified","AUTHORIZATION","documentId","fileExtension","split","pop","uniqueFileName","filePath","uploadError","maxRetries","attempt","upload","upsert","cacheControl","publicUrlData","getPublicUrl","updateError","update","file_path","documentResult","undefined","created_at","waitTime","Math","pow","Promise","resolve","setTimeout","attempts","delete","deleteError","isAppError","UNKNOWN","deleteDocument","document","fetchError","storageError","remove","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { \n  ErrorType, \n  createAppError, \n  logError \n} from '../utils/errorHandling';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'client-documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  try {\n    // First check if the documents table exists\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      console.warn(`Documents table ${DOCUMENTS_TABLE} does not exist.`);\n      return [];\n    }\n\n    const { data, error } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('id, created_at, file_name, file_path, file_type, file_size, category, application_id, client_id, uploaded_by_user_id')\n      .eq('client_id', clientId)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      console.error(`Error fetching documents for client ${clientId}:`, error);\n      throw error;\n    }\n\n    console.log(`Retrieved ${data?.length || 0} documents for client ${clientId}`);\n    return data || [];\n  } catch (error) {\n    console.error(`Error in getClientDocuments for client ${clientId}:`, error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}: DocumentUpload): Promise<Document> => {\n  const supabaseClient = getServiceClient();\n  \n  try {\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(\n        `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        'documentService.uploadDocument',\n        { table: DOCUMENTS_TABLE }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        { table: DOCUMENTS_TABLE }\n      );\n    }\n    \n    // Verificar si el bucket de storage existe\n    const { data: buckets } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets?.some((bucket: any) => bucket.name === STORAGE_BUCKET);\n    \n    if (!bucketExists) {\n      logError(\n        `El bucket ${STORAGE_BUCKET} no existe.`,\n        'documentService.uploadDocument',\n        { bucket: STORAGE_BUCKET }\n      );\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        { bucket: STORAGE_BUCKET }\n      );\n    }\n    \n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n    \n    // Crear registro del documento\n    const { data, error } = await supabaseClient\n      .from(DOCUMENTS_TABLE)\n      .insert({\n        file_name: fileName,\n        file_type: fileType,\n        file_size: fileSize,\n        category,\n        application_id,\n        client_id,\n        uploaded_by_user_id: userId,\n        is_verified: false\n      })\n      .select('*')\n      .single();\n      \n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(\n          `Violación de política RLS al crear documento: ${error.message}`,\n          'documentService.uploadDocument',\n          { error }\n        );\n        throw createAppError(\n          ErrorType.AUTHORIZATION,\n          'No tienes permisos para crear documentos para este cliente o aplicación',\n          { error: error.message }\n        );\n      }\n      \n      logError(\n        `Error al crear documento: ${error.message}`,\n        'documentService.uploadDocument',\n        { error }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos',\n        { error: error.message }\n      );\n    }\n    \n    if (!data) {\n      logError(\n        'No se retornaron datos al crear documento',\n        'documentService.uploadDocument'\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos'\n      );\n    }\n    \n    const documentId = data.id;\n    \n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n    \n    // Intentar subir el archivo con reintentos\n    let uploadError: any = null;\n    const maxRetries = 3;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const { error: uploadError } = await supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            upsert: true,\n            cacheControl: '3600'\n          });\n          \n        if (uploadError) {\n          throw uploadError;\n        }\n        \n        // Obtener URL pública del archivo\n        const { data: publicUrlData } = supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .getPublicUrl(filePath);\n          \n        // Actualizar el documento con la ruta del archivo\n        const { error: updateError } = await supabaseClient\n          .from(DOCUMENTS_TABLE)\n          .update({\n            file_path: filePath\n          })\n          .eq('id', documentId);\n          \n        if (updateError) {\n          logError(\n            `Error al actualizar ruta del documento: ${updateError.message}`,\n            'documentService.uploadDocument',\n            { error: updateError }\n          );\n        }\n        \n        // Construir y devolver el documento\n        const documentResult: Document = {\n          id: documentId,\n          application_id: application_id || undefined,\n          client_id: client_id || undefined,\n          file_name: fileName,\n          file_path: filePath,\n          file_type: fileType,\n          file_size: fileSize,\n          category,\n          uploaded_by_user_id: userId,\n          is_verified: false,\n          created_at: data.created_at\n        };\n        \n        return documentResult;\n      } catch (error) {\n        uploadError = error;\n        \n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    logError(\n      `Error al subir documento después de ${maxRetries} intentos: ${uploadError?.message || 'Error desconocido'}`,\n      'documentService.uploadDocument',\n      { error: uploadError, attempts: maxRetries }\n    );\n    \n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    \n    throw createAppError(\n      ErrorType.UPLOAD,\n      'Error al subir el archivo al sistema',\n      { error: uploadError?.message }\n    );\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && (error as any).isAppError) {\n      throw error;\n    }\n    \n    logError(\n      `Error inesperado en uploadDocument: ${(error as any)?.message || 'Error desconocido'}`,\n      'documentService.uploadDocument',\n      { error }\n    );\n    \n    throw createAppError(\n      ErrorType.UNKNOWN,\n      'Error inesperado al subir documento',\n      { error: (error as any)?.message }\n    );\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}