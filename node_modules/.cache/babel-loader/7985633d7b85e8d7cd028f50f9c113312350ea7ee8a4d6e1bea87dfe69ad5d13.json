{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase } from '../services/supabaseService';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\n\n// Define application interface\n\n// Get all applications with filters\nexport const getApplications = async (filters, entityFilter) => {\n  try {\n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase.from(TABLES.APPLICATIONS).select('*');\n\n    // Aplicar filtro de entidad\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n\n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n\n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        query = query.eq('application_type', filters.application_type);\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n\n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n\n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', {\n      ascending: false\n    });\n\n    // Ejecutar la consulta\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n\n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map(app => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      application_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\",\n      // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined\n    }));\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = dbStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n\n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW;\n  }\n\n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => status.toLowerCase() === normalizedStatus);\n  if (directMapping) {\n    return directMapping;\n  }\n\n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return statusMap[normalizedStatus] || APPLICATION_STATUS.NEW;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async application => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ');\n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id, updates, entityFilter) => {\n  const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`).join(', ');\n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  query += ' RETURNING *';\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (id, status, comment, user_id, entityFilter) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, {\n    entityFilter\n  });\n\n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase.from(TABLES.APPLICATIONS).select('status, assigned_to, company_id').eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: currentStateData,\n      error: fetchError\n    } = await query;\n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, {\n        entityFilter\n      });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n\n    // 2. Update the application using Supabase client\n    const updateData = {\n      status: status,\n      status_previous: currentStatus\n    };\n\n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    let updateQuery = supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n\n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    const {\n      data: updatedApp,\n      error: updateError\n    } = await updateQuery.select();\n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n\n    // 3. Add to history\n    const historyComment = currentStatus !== status ? `${comment} (Cambio de estado: ${currentStatus} → ${status})` : comment;\n    try {\n      const {\n        error: historyError\n      } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n        application_id: id,\n        status: status,\n        comment: historyComment,\n        created_by: user_id\n      });\n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (id, comment, advisor_id, entityFilter) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id)) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_advisor: true,\n      approval_date_advisor: new Date().toISOString(),\n      status: 'approved' // Update the status to 'approved' when advisor approves\n    }).eq('id', id).eq('assigned_to', advisor_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: 'approved',\n      // Cambiado de status_previous/status_new a solo status\n      comment: comment,\n      created_by: advisor_id,\n      created_at: new Date().toISOString()\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'por_dispersar') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'por_dispersar'\");\n\n      // Si ambos han aprobado, actualizar el estado a por_dispersar\n      return await updateApplicationStatus(id, 'por_dispersar', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', advisor_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_company: true,\n      approval_date_company: new Date().toISOString()\n    }).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: 'approved_by_company',\n      // Ya está usando el formato correcto\n      comment: comment,\n      created_by: company_admin_id\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n\n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(id, 'approved', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', company_admin_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const {\n      data: updatedApp,\n      error\n    } = await supabase.from(TABLES.APPLICATIONS).update({\n      approved_by_company: false,\n      approval_date_company: null,\n      status: APPLICATION_STATUS.IN_REVIEW\n    }).eq('id', id).eq('company_id', company_id).select('*');\n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n\n    // Añadir al historial usando Supabase client\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert({\n      application_id: id,\n      status: APPLICATION_STATUS.IN_REVIEW,\n      comment: comment,\n      created_by: company_admin_id\n    });\n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (id, entityFilter) => {\n  // Store last successful result for this application ID\n  const cachedResultKey = `approval_status_${id}`;\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      const appData = data[0];\n\n      // Cache successful result in session storage\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(appData));\n      } catch (e) {\n        // Ignore storage errors\n      }\n      return {\n        approvedByAdvisor: appData.approved_by_advisor,\n        approvedByCompany: appData.approved_by_company,\n        approvalDateAdvisor: appData.approval_date_advisor,\n        approvalDateCompany: appData.approval_date_company\n      };\n    }\n\n    // Check for cached data if no results found\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id}`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    console.warn(`Solicitud ${id} no encontrada, retornando valores por defecto`);\n    return {\n      approvedByAdvisor: undefined,\n      approvedByCompany: undefined,\n      approvalDateAdvisor: undefined,\n      approvalDateCompany: undefined\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] fallo – conservo estado local para solicitud ${id}:`, error);\n\n    // Try to return cached data if available\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id} after error`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n\n    // Return undefined instead of false values\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id, entityFilter) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId, userId, text, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount, interestRate, termMonths) => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n\n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n\n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  const monthlyPayment = loanAmount * (numerator / denominator);\n\n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (id, status, statusField, comment, user_id, entityFilter) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Start a transaction\n    const {\n      data: application,\n      error: fetchError\n    } = await supabase.from(TABLES.APPLICATIONS).select('*').eq('id', id).single();\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : application[statusField] || application.status;\n\n    // Prepare the update data\n    const updateData = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // If advisor_status and company_status are both 'approved', set global_status to 'por_dispersar'\n    if (statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED && application.company_status === APPLICATION_STATUS.APPROVED || statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED && application.advisor_status === APPLICATION_STATUS.APPROVED) {\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      // Also update the main status to reflect this change\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n    } else if (statusField !== 'status') {\n      // For non-global status fields (advisor_status, company_status), also update the main status\n      // This keeps the UI in sync with the specific status field being viewed\n      updateData.status = status;\n    }\n\n    // Update the application\n    const {\n      error: updateError\n    } = await supabase.from(TABLES.APPLICATIONS).update(updateData).eq('id', id);\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n    const {\n      error: historyError\n    } = await supabase.from(APPLICATION_HISTORY_TABLE).insert([historyEntry]);\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n    return {\n      success: true,\n      application: {\n        ...application,\n        [statusField]: status\n      }\n    };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","supabase","executeQuery","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","getApplications","filters","entityFilter","query","from","APPLICATIONS","select","advisor_id","eq","company_id","status","application_type","dateFrom","gte","dateTo","lte","amountMin","amountMax","searchQuery","searchTerm","toLowerCase","or","order","ascending","data","error","console","Array","isArray","length","map","app","id","client_id","source_id","assigned_to","requested_amount","parseFloat","amount","mapStatusFromDB","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","undefined","interest_rate","monthly_payment","dbStatus","log","NEW","normalizedStatus","trim","directMapping","Object","values","find","statusMap","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","getApplicationById","Error","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","key","value","updateApplicationStatus","comment","user_id","currentStateData","fetchError","message","currentStatus","updateData","status_previous","dispersal_date","Date","toISOString","updateQuery","update","updatedApp","updateError","historyComment","historyError","insert","application_id","created_by","historyErr","approveByAdvisor","approveByCompany","company_admin_id","cancelCompanyApproval","getApprovalStatus","cachedResultKey","appData","sessionStorage","setItem","JSON","stringify","e","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","cachedData","getItem","parsedData","parse","warn","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments","calculateMonthlyPayment","loanAmount","interestRate","termMonths","monthlyInterestRate","numerator","Math","pow","denominator","monthlyPayment","round","updateApplicationStatusField","statusField","includes","single","previousStatus","company_status","advisor_status","global_status","historyEntry","previous_status","new_status","status_field","changed_by","comments","changed_at","success"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { supabase, getServiceClient } from '../services/supabaseService';\nimport { executeQuery, escapeSqlString } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  application_type: string;\n  product_type?: string;  // Tipo de producto (préstamo personal, auto, etc.)\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  client_phone?: string;\n  client_address?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  dni?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  try {\n    // Usar directamente la API de Supabase en lugar de SQL manual\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*');\n    \n    // Aplicar filtro de entidad\n    if (entityFilter?.advisor_id) {\n      query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    \n    if (entityFilter?.company_id) {\n      query = query.eq('company_id', entityFilter.company_id);\n    }\n    \n    // Aplicar filtros de búsqueda\n    if (filters) {\n      // Filtro por estado\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n      \n      // Filtro por tipo de aplicación\n      if (filters.application_type) {\n        query = query.eq('application_type', filters.application_type);\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query = query.eq('assigned_to', filters.advisor_id);\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n      \n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      \n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n      \n      // Filtros de monto\n      if (filters.amountMin) {\n        query = query.gte('amount', filters.amountMin);\n      }\n      \n      if (filters.amountMax) {\n        query = query.lte('amount', filters.amountMax);\n      }\n      \n      // Búsqueda por texto\n      if (filters.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase();\n        query = query.or(`client_name.ilike.%${searchTerm}%,client_email.ilike.%${searchTerm}%,company_name.ilike.%${searchTerm}%`);\n      }\n    }\n    \n    // Ordenar por fecha de creación más reciente\n    query = query.order('created_at', { ascending: false });\n    \n    // Ejecutar la consulta\n    const { data, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching applications:', error);\n      return [];\n    }\n    \n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return [];\n    }\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      application_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\", // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      \n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n    })) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    // Return empty array instead of throwing to prevent UI crashes\n    return [];\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string): ApplicationStatus => {\n  // Si el estado es null, undefined, o una cadena vacía, asumimos que es NEW\n  if (!dbStatus) {\n    console.log('Estado vacío o nulo, mapeando a NEW');\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Normalizamos para comparar\n  const normalizedStatus = dbStatus.toLowerCase().trim();\n  \n  // Estos estados siempre deben considerarse como 'new'\n  if (normalizedStatus === 'solicitud' || normalizedStatus === 'pending') {\n    console.log(`Mapeando estado \"${dbStatus}\" a \"new\"`);\n    return APPLICATION_STATUS.NEW as ApplicationStatus;\n  }\n  \n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === normalizedStatus\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'solicitud': APPLICATION_STATUS.NEW,\n    'pendiente': APPLICATION_STATUS.NEW,\n    'pending': APPLICATION_STATUS.NEW,\n    'en revisión': APPLICATION_STATUS.IN_REVIEW,\n    'revisión': APPLICATION_STATUS.IN_REVIEW,\n    'aprobado': APPLICATION_STATUS.APPROVED,\n    'rechazado': APPLICATION_STATUS.REJECTED,\n    'por dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'completado': APPLICATION_STATUS.COMPLETED,\n    'cancelado': APPLICATION_STATUS.CANCELLED,\n    'expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[normalizedStatus] || APPLICATION_STATUS.NEW}\"`);\n  return (statusMap[normalizedStatus] || APPLICATION_STATUS.NEW) as ApplicationStatus;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  console.log(`[updateApplicationStatus] Updating status for application ${id} to ${status}`, { entityFilter });\n  \n  // 1. Obtener estado actual de la aplicación\n  try {\n    // Use Supabase client directly instead of SQL query for better reliability\n    let query = supabase\n      .from(TABLES.APPLICATIONS)\n      .select('status, assigned_to, company_id')\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n        query = query.eq('assigned_to', entityFilter.advisor_id);\n    }\n    if (entityFilter.company_id) {\n        query = query.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: currentStateData, error: fetchError } = await query;\n    \n    if (fetchError) {\n      console.error(`[updateApplicationStatus] Error fetching application ${id}:`, fetchError);\n      throw new Error(`Error fetching application: ${fetchError.message}`);\n    }\n    \n    if (!currentStateData || currentStateData.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied: ${id}`, { entityFilter });\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentStateData[0].status;\n    console.log(`[updateApplicationStatus] Current status: ${currentStatus}, New status: ${status}`);\n    \n    // 2. Update the application using Supabase client\n    const updateData: Partial<Application> = {\n      status: status,\n      status_previous: currentStatus\n    };\n    \n    // If the new status is \"completed\", update the dispersal date\n    if (status === 'completed') {\n      updateData.dispersal_date = new Date().toISOString();\n    }\n    \n    let updateQuery = supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n    \n    // Apply entity filter if needed\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery = updateQuery.eq('assigned_to', entityFilter.advisor_id);\n      }\n      if (entityFilter.company_id) {\n        updateQuery = updateQuery.eq('company_id', entityFilter.company_id);\n      }\n    }\n    \n    const { data: updatedApp, error: updateError } = await updateQuery.select();\n    \n    if (updateError) {\n      console.error(`[updateApplicationStatus] Error updating application ${id}:`, updateError);\n      throw new Error(`Error updating application: ${updateError.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      console.error(`[updateApplicationStatus] Application not found or permission denied during update: ${id}`);\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Add to history\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    try {\n      const { error: historyError } = await supabase\n        .from(APPLICATION_HISTORY_TABLE)\n        .insert({\n          application_id: id,\n          status: status,\n          comment: historyComment,\n          created_by: user_id\n        });\n      \n      if (historyError) {\n        console.error(`[updateApplicationStatus] Error adding to history for application ${id}:`, historyError);\n        // We don't throw here to avoid disrupting the status update\n      }\n    } catch (historyErr) {\n      console.error(`[updateApplicationStatus] Error adding to history:`, historyErr);\n      // We don't throw here to avoid disrupting the status update\n    }\n    \n    console.log(`[updateApplicationStatus] Successfully updated status: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`[updateApplicationStatus] Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  try {\n    console.log(`Aprobando solicitud ${id} por asesor ${advisor_id}...`);\n    \n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_advisor: true,\n        approval_date_advisor: new Date().toISOString(),\n        status: 'approved' // Update the status to 'approved' when advisor approves\n      })\n      .eq('id', id)\n      .eq('assigned_to', advisor_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    console.log(`Solicitud ${id} aprobada exitosamente por asesor ${advisor_id}`);\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: 'approved', // Cambiado de status_previous/status_new a solo status\n        comment: comment,\n        created_by: advisor_id,\n        created_at: new Date().toISOString()\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    } else {\n      console.log(`Historial registrado para la solicitud ${id}`);\n    }\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'por_dispersar') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'por_dispersar'\");\n      \n      // Si ambos han aprobado, actualizar el estado a por_dispersar\n      return await updateApplicationStatus(\n        id, \n        'por_dispersar', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        advisor_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_company: true,\n        approval_date_company: new Date().toISOString()\n      })\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al aprobar solicitud: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: 'approved_by_company', // Ya está usando el formato correcto\n        comment: comment,\n        created_by: company_admin_id\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de aprobación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        company_admin_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Cancelar aprobación de una empresa\nexport const cancelCompanyApproval = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  try {\n    // Utilizar el cliente Supabase directamente en lugar de SQL crudo\n    const { data: updatedApp, error } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update({\n        approved_by_company: false,\n        approval_date_company: null,\n        status: APPLICATION_STATUS.IN_REVIEW\n      })\n      .eq('id', id)\n      .eq('company_id', company_id)\n      .select('*');\n    \n    if (error) {\n      console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n      throw new Error(`Error al cancelar aprobación: ${error.message}`);\n    }\n    \n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para cancelar la aprobación');\n    }\n    \n    // Añadir al historial usando Supabase client\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert({\n        application_id: id,\n        status: APPLICATION_STATUS.IN_REVIEW,\n        comment: comment,\n        created_by: company_admin_id\n      });\n    \n    if (historyError) {\n      console.error(`Error al registrar historial de cancelación:`, historyError);\n      // No interrumpimos el flujo por errores en el historial\n    }\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error cancelando aprobación de solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Store last successful result for this application ID\n  const cachedResultKey = `approval_status_${id}`;\n  \n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      const appData = data[0] as {\n        approved_by_advisor: boolean,\n        approved_by_company: boolean,\n        approval_date_advisor: string,\n        approval_date_company: string\n      };\n      \n      // Cache successful result in session storage\n      try {\n        sessionStorage.setItem(cachedResultKey, JSON.stringify(appData));\n      } catch (e) {\n        // Ignore storage errors\n      }\n      \n      return {\n        approvedByAdvisor: appData.approved_by_advisor,\n        approvedByCompany: appData.approved_by_company,\n        approvalDateAdvisor: appData.approval_date_advisor,\n        approvalDateCompany: appData.approval_date_company\n      };\n    }\n    \n    // Check for cached data if no results found\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id}`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    \n    console.warn(`Solicitud ${id} no encontrada, retornando valores por defecto`);\n    return {\n      approvedByAdvisor: undefined,\n      approvedByCompany: undefined,\n      approvalDateAdvisor: undefined,\n      approvalDateCompany: undefined\n    };\n  } catch (error) {\n    console.error(`[getApprovalStatus] fallo – conservo estado local para solicitud ${id}:`, error);\n    \n    // Try to return cached data if available\n    try {\n      const cachedData = sessionStorage.getItem(cachedResultKey);\n      if (cachedData) {\n        console.log(`Using cached approval status for ${id} after error`);\n        const parsedData = JSON.parse(cachedData);\n        return {\n          approvedByAdvisor: parsedData.approved_by_advisor,\n          approvedByCompany: parsedData.approved_by_company,\n          approvalDateAdvisor: parsedData.approval_date_advisor,\n          approvalDateCompany: parsedData.approval_date_company\n        };\n      }\n    } catch (e) {\n      // Ignore storage errors\n    }\n    \n    // Return undefined instead of false values\n    return undefined;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as { \n      id: string;\n      application_id: string;\n      user_id: string;\n      text: string;\n      created_at: string;\n    };\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\nexport interface ApplicationWithClient {\n  // ... existing code ...\n}\n\n/**\n * Calcula el pago mensual de un préstamo basado en el monto, tasa de interés y plazo\n * @param loanAmount - Monto del préstamo \n * @param interestRate - Tasa de interés anual (en decimales, ej: 0.12 para 12%)\n * @param termMonths - Plazo en meses\n * @returns Pago mensual calculado\n */\nexport const calculateMonthlyPayment = (loanAmount: number, interestRate: number, termMonths: number): number => {\n  // Convertir tasa de interés anual a mensual\n  const monthlyInterestRate = interestRate / 12;\n  \n  // Si la tasa es 0, simplemente dividir el monto entre los meses\n  if (interestRate === 0) {\n    return loanAmount / termMonths;\n  }\n  \n  // Fórmula para calcular pago mensual: P = L[r(1+r)^n]/[(1+r)^n-1]\n  // Donde: P = pago mensual, L = monto del préstamo, r = tasa mensual, n = número de pagos\n  const numerator = monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths);\n  const denominator = Math.pow(1 + monthlyInterestRate, termMonths) - 1;\n  \n  const monthlyPayment = loanAmount * (numerator / denominator);\n  \n  // Redondear a 2 decimales y devolver\n  return Math.round(monthlyPayment * 100) / 100;\n};\n\n// Update a specific status field (advisor_status, company_status, or global_status)\nexport const updateApplicationStatusField = async (\n  id: string, \n  status: Application['status'],\n  statusField: 'advisor_status' | 'company_status' | 'global_status' | 'status',\n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  try {\n    // Validate the status field\n    if (!['advisor_status', 'company_status', 'global_status', 'status'].includes(statusField)) {\n      throw new Error(`Invalid status field: ${statusField}`);\n    }\n\n    // Start a transaction\n    const { data: application, error: fetchError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching application with ID ${id}:`, fetchError);\n      throw fetchError;\n    }\n\n    if (!application) {\n      throw new Error(`Application with ID ${id} not found`);\n    }\n\n    // Apply entity filter if provided\n    if (entityFilter) {\n      if (entityFilter.advisor_id && application.assigned_to !== entityFilter.advisor_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n      if (entityFilter.company_id && application.company_id !== entityFilter.company_id) {\n        throw new Error('You do not have permission to update this application status');\n      }\n    }\n\n    // Save the previous status to record the change\n    const previousStatus = statusField === 'status' ? application.status : (application[statusField] || application.status);\n\n    // Prepare the update data\n    const updateData: Record<string, any> = {\n      [statusField]: status,\n      updated_at: new Date().toISOString()\n    };\n\n    // If advisor_status and company_status are both 'approved', set global_status to 'por_dispersar'\n    if (\n      (statusField === 'advisor_status' && status === APPLICATION_STATUS.APPROVED && application.company_status === APPLICATION_STATUS.APPROVED) ||\n      (statusField === 'company_status' && status === APPLICATION_STATUS.APPROVED && application.advisor_status === APPLICATION_STATUS.APPROVED)\n    ) {\n      updateData.global_status = APPLICATION_STATUS.POR_DISPERSAR;\n      // Also update the main status to reflect this change\n      updateData.status = APPLICATION_STATUS.POR_DISPERSAR;\n    } else if (statusField !== 'status') {\n      // For non-global status fields (advisor_status, company_status), also update the main status\n      // This keeps the UI in sync with the specific status field being viewed\n      updateData.status = status;\n    }\n\n    // Update the application\n    const { error: updateError } = await supabase\n      .from(TABLES.APPLICATIONS)\n      .update(updateData)\n      .eq('id', id);\n\n    if (updateError) {\n      console.error(`Error updating ${statusField} for application ${id}:`, updateError);\n      throw updateError;\n    }\n\n    // Record the status change in the history\n    const historyEntry = {\n      application_id: id,\n      previous_status: previousStatus,\n      new_status: status,\n      status_field: statusField,\n      changed_by: user_id,\n      comments: comment || `Status changed from ${previousStatus} to ${status}`,\n      changed_at: new Date().toISOString()\n    };\n\n    const { error: historyError } = await supabase\n      .from(APPLICATION_HISTORY_TABLE)\n      .insert([historyEntry]);\n\n    if (historyError) {\n      console.error(`Error recording status history for application ${id}:`, historyError);\n      // Don't throw, as the primary operation succeeded\n    }\n\n    return { success: true, application: { ...application, [statusField]: status } };\n  } catch (error) {\n    console.error('Error updating application status field:', error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}